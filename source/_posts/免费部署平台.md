---
title: 免费部署平台
tags:
  - 部署
categories:
  - 大前端
abbrlink: aa5fe28c
date: 2021-10-24 18:52:15
---



## Github Pages

- 将项目提交到github后，启动github pages，其会生成一个网址，这个网址默认打开当前分支下的README.md或index.html

![](免费部署平台/1.jpg)

![](免费部署平台/2.jpg)

- Github Actions（自动部署，只要代码一提交，就会自动发布到服务器上）

  1. 个人设置 - Personal access tokens

  ![](免费部署平台/3.jpg)

  ![](免费部署平台/4.jpg)

  ![](免费部署平台/5.jpg)

  ![](免费部署平台/6.jpg)

  - `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`
  
2. 本地项目，创建 .github/workflows/deploy.yml，写入如下代码
  
   ```javascript
     name: GitHub Actions Build and Deploy Demo
     on:     # on表示触发的条件
       push:
         branches:
           - master    # 当我们往master分支去push时，会执行下方任务
     jobs:   # jobs表示要做的工作
       build-and-deploy:
         runs-on: ubuntu-latest    # 此处是一个临时的操作系统（就是一个docker）
         steps:
         - name: Checkout    # 第一个任务：把当前项目克隆（checkout）下来
           uses: actions/checkout@v2.3.1
         - name: Install and Build # 第二个任务：执行安装和打包操作
           run: |
             npm install
             npm run build
     
         - name: Deploy    # 第三个任务：新建分支，并将打包好的dist目录发布到当前分支
           uses: JamesIves/github-pages-deploy-action@4.1.5
           with:
             branch: gh-pages
             folder: dist
     # https://github.com/marketplace/actions/deploy-to-github-pages
     ```
  
   
  
   
  
3. 本地项目，package.json 中增加
  
   ```json
     {
       ......
       "homepage": "https://xxc-yqxz.github.io/vue-demo",
     }
     ```
  
   
  
4. 本地项目，创建 vue.config.js
  
   ```javascript
     module.exports = {
         outputDir: 'dist',
         publicPath: process.env.NODE_ENV === 'production' ? '/vue-demo/' : '/'
     }
     ```
  
5. 设置Secrets
  
![](免费部署平台/7.jpg)
  
![](免费部署平台/8.jpg)
  

  
6. 执行git 提交操作
  
```javascript
  git add .
  git commit -m "delpoy"
  git push
  ```
  
7. 此时我们可以在仓库的Actions选项中看到如下配置操作：
  
![](免费部署平台/9.jpg)
  
8. 当显示全部执行完后，可以看到新生成了gh-pages分支，最后我们将git pages的分支改为gh-pages：
  
![](免费部署平台/10.jpg)
  
![](免费部署平台/11.jpg)
  
9. 此后一旦我们改了代码后，只要将其发布到github上，我们访问github pages提供的网址都能直接看到改变（有时会有延迟，要等Actions执行完）
  10. 此外我们还可以使用自定义域名，需要先在阿里云中进行域名解析，之后在pages的Custom domain中填入解析后的域名（此处及为http://blogs.xxcijmz.top）。需要注意，第一次填写域名会自动打包，并生成CNAME文件记录填入的域名（之后打包都需要将这个文件一同打包，否则自定义域名会失效，不过貌似仓库之间共用，因为github提供的地址的前缀是类似的，当我们进行域名解析时将域名指向github提供的地址的前面部分，这样只要有一个仓库有了CNAME文件，就能使得github提供的地址与解析的域名相呼应，而我们只需要在后面添加相关仓库名即可实现自定义域名），之后我们再访问内容（通过http://blogs.xxcijmz.top访问），如果按之前的vue.config.js中的配置，会在所有文件之前加上http://blogs.xxcijmz.top/vue-demo/，导致文件加载不出来（因为文件的根目录没有vue-demo）。



## [Vercel](https://vercel.com)

> Vercel既可以部署静态页面程序，也可以部署基于node开发的程序或其它语言的程序。

- 部署文档

  - https://nuxtjs.org/faq/now-deployment
  - https://www.nuxtjs.cn/faq/now-deployment

- 在 Vercel 的网站使用 github 账号登录

- 全局安装 vercel

  ```bash
  yarn global add vercel  /  npm install vercel -g
  ```

- 创建配置文件 now.json or vercel.json

  ```json
  {
    "version": 2,
    "builds": [
      {
        "src": "nuxt.config.js",
        "use": "@nuxtjs/now-builder"
      }
    ]
  }
  ```

- 在项目根目录中执行npm run dev

![](免费部署平台/12.jpg)

- .nowignore

  新建.nowignore文件（效果类似于.gitignore），忽略构建的文件夹 .nuxt

  ```
  .nuxt
  ```

- 发布

  - 登陆

  ```bash
  vercel login
  ```

  ![](免费部署平台/13.jpg)

  - 发布

  ```bash
  vercel			// 使用此种方式，会使用测试域名（realworld-nuxtjs-xxc-yqxz.vercel.app）
  
  vercel --prod	// 使用此种方式，可以使用正式版域名（realworld-nuxtjs-eta.vercel.app）
  
  vercel dev    // 测试执行，不会部署
  ```

  ![](免费部署平台/14.jpg)

  发布完毕后，首页是静态的，可以直接查看到，但是需要请求接口的地方，比如：登录 会出错。

  点击登录按钮的时候会在控制台提示，在https的主域名下访问接口的时候，接口地址也需要使用 https。

  ![](免费部署平台/15.jpg)

- 修改 baseUrl，把接口地址更改成 https 的

  在 plugins/request.js

  ```js
  export const request = axios.create({
    // baseURL: 'http://realworld.api.fed.lagounews.com'
    baseURL: 'https://conduit.productionready.io'
  })
  ```


## Serverless

- Serverless 是一种架构模式，无服务器架构
  - 对于使用 Serverless 架构进行开发的项目，开发者最明显的感受就是更关注应用的业务本身，不必再去过多关心服务器和运行平台的一系列问题
- 无服务器，并不是真的没有服务器，只是开发人员眼中不需要关注服务器。开发人员只需要按照一定的要求完成开发工作，剩下的所有事情全部交给 Serverless 容器完成。
- 我们的应用主要由两大块组成，分别是**逻辑**与**存储**。Serverless 中就通过两种方式解决了这两块的需求，分别是：
  - 函数即服务，Function as a Service，FaaS；
  - 后端即服务，Backend as a Service，BaaS。

- Serverless 的优势
  - 不需要再考虑什么物理机/虚拟机，结合工作流的情况下，代码提交自动部署，直接运行；
  - 没有服务器，维护成本自然大大降低，安全性稳定性更高；
  - 都是弹性伸缩云，硬件资源需要多少分配多少，不用担心性能问题；
  - 大多数 Serverless 服务商的计价方式都是按使用情况（如流量、CPU 占用）来收费；

- Vercel Serverless 文档
  - https://vercel.com/docs
  - https://vercel.com/docs/runtimes#official-runtimes/node-js/node-js-dependencies
- demo1
  - 本地测试 vercel dev

1. 在本地新建项目文件目录，并写入如下代码：

![](免费部署平台/16.jpg)

```js
module.exports = (req, res) => {
  const { name = 'World' } = req.query
  res.status(200).send(`Hello ${name}!`)
}
```

2. 在终端使用vercel 进行部署

![](免费部署平台/17.jpg)

3. 访问相关地址，即可获取数据

![](免费部署平台/18.jpg)

- demo2

可以在node中间层去获取多个接口的数据，然后合并。

此处获取一个接口的数据后渲染成li

```js
import axios from 'axios'
module.exports = async (req, res) => {
  // const { name = 'World' } = req.query
  const { data } = await axios.get('https://conduit.productionready.io/api/tags')
  let html = '<ul>'
  data.tags.forEach(item => {
    html += `<li>${item}</li>`
  })
  html += '</ul>'
  res.status(200).send(html)
}
```

- demo3

```js
module.exports = (req, res) => {
  const data = require('../data.json')
  res.json(data)
}
```

- demo4

在项目根目录中新建vercel.json，写入如下代码：

```json
{
  "version": 2,
  "routes": [
    { "src": "/api/server/(.*)", "dest": "/api/server.js" }		// 表示当请求/api/server是会转发到/api/server.js中处理请求。
  ]
}
```

新建server.js，写入如下代码：

```js
const path = require('path')
const jsonServer = require('json-server')
const server = jsonServer.create()
const router = jsonServer.router(path.join(__dirname, '../db.json'))
const middlewares = jsonServer.defaults()

server.use(middlewares)
server.use(router)

module.exports = server
```

其中db.json如下：

```json
{
    "posts": [
        {
            "id": 1,
            "title": "json-111server",
            "author": "typicode",
            "apiId": "server"
        },
        {
            "id": 2,
            "title": "json-111server",
            "author": "typicode",
            "apiId": "server"
        }
    ],
    "comments": [
        {
            "id": 1,
            "body": "some comment",
            "postId": 1
        }
    ],
    "profile": {
        "name": "typicode"
    }
}
```



此后访问/api/server即可获取数据

![](免费部署平台/19.jpg)

同时也可以使用postman进行添加（注意json-server只能识别有apiId的数据）：

![](免费部署平台/20.jpg)

但是当我们使用线上地址时，执行vercel前要先在package.json中配置依赖安装json-server，否则会提示无法找到。

同时即便可以找到，但是当我们进行修改时，会报如下错误，提示文件是只读的：

![](免费部署平台/21.jpg)

此时，我们需要把db.json放到临时文件夹中，使得其可以支持读写。代码修改如下：

```js
const path = require('path')
const os = require('os')
const fs = require('fs')
const jsonServer = require('json-server')
const server = jsonServer.create()

const middlewares = jsonServer.defaults()

const dbFilename = path.join(os.tmpdir(), 'db.json')

// 判断一下 dbFilename 是否存在，如果不存在才创建
if (!fs.existsSync(dbFilename)) {
  fs.writeFileSync(dbFilename, JSON.stringify({
    "posts": [
      { "id": 1, "title": "json-server", "author": "typicode", "apiId": "server" },
      { "id": 2, "title": "iis", "author": "ms", "apiId": "server" }
    ],
    "comments": [
      { "id": 1, "body": "some comment", "postId": 1, "apiId": "server" }
    ],
    "profile": { "name": "typicode", "apiId": "server" }
  }))
}

const router = jsonServer.router(dbFilename)
server.use(middlewares)
server.use(router)

module.exports = server
```