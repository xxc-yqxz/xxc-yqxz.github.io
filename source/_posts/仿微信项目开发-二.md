---
title: 仿微信项目开发(二)
abbrlink: joiasdd
date: 2021-11-03 22:48:07
tags:
	- Vue
	- uniapp
categories:
	- 项目开发
---

## 聊天页导航开发

首先，我们需要新建一个聊天页面 **`pages/chat/chat.nvue`**（确保其有在pages.json中注册），然后在 **`my-chat-list.vue`** 中为 点击事件 添加跳转效果。

**`my-chat-list.vue`**

```html
<template>
	<!-- 列表 -->
		<view :class="( isHover || chatData.istop)?'bg-hover-light':'bg-white'">
			<div class="flex align-stretch" @click="onClick" @longpress="onLongPress">
			</div>
            ...
		</view>
</template>

<script>
export default {
    ...
	methods: {
        ...
		/**
		 * 点击事件
		 */
		onClick() {
			this.isHover = true
			setTimeout(()=>{
				this.isHover = false
			},200)
			uni.navigateTo({
				url:'/pages/chat/chat'
			})
		},
	},
};
</script>
```

然后由于 **chat.nvue** 中要使用到 **`my-nav-bar`** 组件，使用时需要为其添加 一个 返回图标，所以我们需要再修改一下 **`my-nav-bar`** 

```html
<template>
	<view >
		<!-- 导航栏 -->
		<view :class="computeClass">
			<!-- 状态栏 -->
			<!-- 此处的 statusBarHeight 是动态获取的，所以应该用 'px' 作为单位 -->
			<!-- 主要用于填充状态栏的高度 -->
			<view :style="'height:' + statusBarHeight + 'px'"></view>
			<!-- 导航 -->
			<view
				class="w-100 flex align-center justify-between bg-nav"
				style="height: 90rpx"
			>
				<!-- 左边区域 -->
				<view class="flex align-center">
					<!-- 返回按钮 -->
					<myIconButton v-if="showBackIcon" :icon="'\ueb15'" @click="backToIndex"></myIconButton>
					<!-- 左边标题区域 -->
					<text v-if="title" class="ml-3 font-md">{{computeTitle}}</text>
				</view>
				<!-- 右边区域 -->
				<view class="flex align-center">
					<slot name="right">
						<!-- 右边图标区域 -->
						<myIconButton :icon="'\ue62f'" @click="loadSearchPopup"></myIconButton>
						<myIconButton :icon="'\ue657'" @click="loadExtendPopup"></myIconButton>
					</slot>
				</view>
			</view>
		</view>
	</view>
</template>

<script>
    export default {
    ...
        props:{
            ...
            showBackIcon:{
                type:Boolean,
                    default:false
            },
        },
        methods:{
            ...
            // 返回主页事件
            backToIndex(){
                uni.navigateBack({
                    delta:-1
                })
            }
        },
    }
</script>
```

在 **`chat.nvue`** 中使用：

```html
<template>
	<view>
		<!-- 导航栏 -->
		<myNavBar showBackIcon="true" title="久美子" @loadSearchPopup="showPopup">
			<myIconButton slot="right" :icon="'\uec1c'"></myIconButton>
		</myNavBar>
	</view>
</template>
```

## 聊天页底部输入框开发

**`chat.nvue`**

```html
<template>
	<view>
        ...
		<!-- 底部输入框 -->
		<view class="position-fixed flex align-center left-0 right-0 bottom-0 border-top" style="background-color: #F7F7F6;height: 105rpx;">
			<myIconButton :icon="'\ue684'"></myIconButton>
			<!-- 需要给 其加 flex-1 ，否则会溢出 -->
			<view class="flex-1">
				<!-- 需要给 textarea 手动设置高度 -->
				<textarea fixed class="bg-white rounded p-1 font-md" style="height: 75rpx;"/>
			</view>
			<myIconButton :icon="'\ue640'"></myIconButton>
			<myIconButton :icon="'\ue726'"></myIconButton>
		</view>
	</view>
</template>
```

## 开发聊天内容区域

```html
<template>
	<view>
		<!-- 聊天内容区域 -->
        <!-- 通过给其添加固定定位，并给固定定位设置一个跟导航栏高度一样的 top属性值，跟底部输入框一样的 bottom 属性值，来将其固定到中间位置  -->
		<!-- 注意：fixed 定位是相对于浏览器窗口定位，无法相对父元素定位，这会导致若一个元素只有一个具有高度的子元素 -->
		<!-- 一旦这个子元素设置了绝对定位，父元素高度就会变为0，这也是为什了 my-nav-bar 中要设置 一个用于占位的 view 标签的原因 -->
		<scroll-view scroll-y class="bg-danger position-fixed left-0 right-0" style="bottom:105rpx" :style="'top:'+navBarHeight+'px'">
			<view style="height: 200rpx;" v-for="i in 20" :key="i">
				<text class="text-white font-lg">{{i}}</text>
			</view>
		</scroll-view>
	</view>
</template>
```

## 聊天气泡组件开发（一）

本节写左边的聊天气泡的样式：

注意： nvue 中最外层标签使用 flex 布局时且在这个标签中的 text 标签的外层标签中设置了 max-width时，此时这个 text标签 的外层标签的 高度会被固定为100，我们需要给 最外层标签添加 align-start，才能是 这个 text标签 的外层标签 的高度被 text 中的文本内容撑开。

```html
<template>
	<view>
        ...
<scroll-view scroll-y class="px-3 position-fixed bg-light left-0 right-0" style="bottom:105rpx" :style="'top:'+navBarHeight+'px'">
			<!-- 聊天信息列表组件 -->
			<!-- 此处为了适配 nvue 端，当使用 flex布局且文字的父容器使用了 max-width 来限制宽度时（此时nvue 中貌似会将父容器的高度限制为100），要加 align-start，否则文字将无法撑开容器高度 -->
			<view class="flex align-start">
				<myAvatar size="70" src="/static/images/demo/demo.jpg"></myAvatar>
				<div class="bg-white p-2 rounded ml-3" style="max-width:500rpx">
					<text class="font-md">你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好111</text>
				</div>
			</view>
		</scroll-view>
       ...
	</view>
</template>
```

## 聊天气泡组件开发（二）

本节来实现右边的聊天气泡的样式，同时通过图标加定位的方式添加气泡旁的三角：

```html
<template>
	<view>
        ...
		<scroll-view scroll-y class="px-3 position-fixed bg-light left-0 right-0" style="bottom:105rpx" :style="'top:'+navBarHeight+'px'">
			<!-- 左边聊天框 -->
			<!-- 此处为了适配 nvue 端，当使用 flex布局且文字的父容器使用了 max-width 来限制宽度时（此时nvue 中貌似会将父容器的高度限制为100），要加 align-start，否则文字将无法撑开容器高度 -->
			<view class="flex align-start position-relative mb-3">
				<myAvatar size="70" src="/static/images/demo/demo.jpg"></myAvatar>
                <!-- 左侧三角图标 -->
				<text class="iconfont text-white font-md position-absolute chat-left-icon">&#xe627;</text>
				<div class="bg-white p-2 rounded ml-3" style="max-width:500rpx">
					<text class="font-md">你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好111</text>
				</div>
			</view>
			
			<!-- 右边聊天框 -->
			<view class="flex align-start justify-end mb-3">
				<div class="bg-chat-color p-2 rounded mr-3" style="max-width:500rpx">
					<text class="font-md">你好你好你好你好你好你好你好你好你好你好你好你好你好你好你好111</text>
				</div>
                <!-- 右侧三角图标 -->
				<text class="iconfont main-text-color font-md position-absolute chat-right-icon">&#xe626;</text>
				<myAvatar size="70" src="/static/images/demo/demo.jpg"></myAvatar>
			</view>
		</scroll-view>
        ...
	</view>
</template>
<style scoped>
.chat-left-icon{
	left: 80rpx;
	top: 20rpx;
}
.chat-right-icon{
	right: 80rpx;
	top: 20rpx;
}
</style>
```

## 封装聊天气泡组件（一）

本节主要实现一下 根据 用户id 来区分是 用户本人还是 好友，从而为聊天气泡设置不同的样式：

**`chat.nvue`**

```html
<template>
	<view>
        ...
		<scroll-view scroll-y class="px-3 position-fixed bg-light left-0 right-0" style="bottom:105rpx" :style="'top:'+navBarHeight+'px'">
			<!-- 聊天信息列表组件 -->
			<block v-for="(item,index) in list" :key="index">
              <!-- 此处判断为 气泡处于 右边还是左边 -->
			<view class="flex align-start position-relative mb-3" :class="item.user_id === 1?'justify-end':''">
				
				<!-- 如果是好友 -->
				<template v-if="item.user_id !== 1">
					<myAvatar size="70" :src="item.avatar"></myAvatar>
					<text class="iconfont text-white font-md position-absolute chat-left-icon">&#xe627;</text>
				</template>
				
                <!-- 判断气泡的颜色及 margin 值的方向 -->
				<div class="p-2 rounded ml-3" :class="item.user_id === 1 ? 'bg-chat-color mr-3':'bg-white ml-3'" style="max-width:500rpx">
					<text class="font-md">{{item.data}}</text>
				</div>
				
				<!-- 如果是本人 -->
				<template v-if="item.user_id === 1">
					<text class="iconfont main-text-color font-md position-absolute chat-right-icon">&#xe626;</text>
					<myAvatar size="70" :src="item.avatar"></myAvatar>
				</template>
				
			</view>
			</block>
		</scroll-view>
	</view>
</template>
<script>
	export default {
        ...
		data() {
			return {
				navBarHeight:0,
				list:[{
					avatar:"/static/images/demo/demo.jpg",
					user_id:1,
					type:'text',		// image,audio,video,file....
					data:"你好你好你好你好"
				},{
					avatar:"/static/images/demo/demo.jpg",
					user_id:2,
					type:'text',		// image,audio,video,file....
					data:"123456你好你好你好你好"
				}]
			}
		},
	}
</script>
```

## 封装聊天气泡组件（二）

本节 将专门创建一个 组件： **`my-chat-item.vue`** ，用于封装聊天气泡，并在 **`chat.nvue`** 中进行使用：

**`my-chat-item.vue`**

```html
<template>
	<!-- 此处为了适配 nvue 端，当使用 flex布局且文字的父容器使用了 max-width 来限制宽度时（此时nvue 中貌似会将父容器的高度限制为100），要加 align-start，否则文字将无法撑开容器高度 -->
    <view class="flex align-start position-relative mb-3" :class="computeIsSelf?'justify-end':''">
    	
    	<!-- 如果是好友 -->
    	<template v-if="!computeIsSelf">
    		<myAvatar size="70" :src="item.avatar"></myAvatar>
    		<text class="iconfont text-white font-md position-absolute chat-left-icon">&#xe627;</text>
    	</template>
    	
    	<div class="p-2 rounded ml-3" :class="computeIsSelf ? 'bg-chat-color mr-3':'bg-white ml-3'" style="max-width:500rpx">
    		<text class="font-md">{{item.data}}</text>
    	</div>
    	
    	<!-- 如果是本人 -->
    	<template v-if="computeIsSelf">
    		<text class="iconfont main-text-color font-md position-absolute chat-right-icon">&#xe626;</text>
    		<myAvatar size="70" :src="item.avatar"></myAvatar>
    	</template>
    	
    </view>
    
</template>

<script>
  import myAvatar from '@/components/my-ui/my-avatar.vue'
  export default {
			props:{
				item:{
					type:Object,
					default:{}
				},
				index:{
					type:Number|String,
					required:true
				}
			},
			components:{
				myAvatar
			},
			computed:{
				computeIsSelf(){
					// 此处假设 本人id 已经获取
					const myId = 1 
					return this.item.user_id === myId ? true :false
				}
			},
    }
</script>

<style scoped>
.chat-left-icon{
	left: 80rpx;
	top: 20rpx;
}
.chat-right-icon{
	right: 80rpx;
	top: 20rpx;
}
</style>
```

**`chat.nvue`**

```html
<template>
	<view>
        ...
		<!-- 聊天内容区域 -->
		<scroll-view scroll-y class="px-3 position-fixed bg-light left-0 right-0" style="bottom:105rpx" :style="'top:'+navBarHeight+'px'">			
			<block v-for="(item,index) in list" :key="index">
				<myChatItem :item="item" :index="index"></myChatItem>
			</block>
		</scroll-view>
        ...
	</view>
</template>
<script>
	import myChatItem from '@/components/my-ui/my-chat-item.vue'
	export default {
        ...
		data() {
			return {
                ...
				list:[{
					avatar:"/static/images/demo/demo.jpg",
					user_id:1,
					type:'text',		// image,audio,video,file....
					data:"你好你好你好你好"
				},{
					avatar:"/static/images/demo/demo.jpg",
					user_id:2,
					type:'text',		// image,audio,video,file....
					data:"123456你好你好你好你好"
				}]
			}
		},
		components:{
            ...
			myChatItem
		},
	}
</script>
```

## 聊天时间人性显示

此处使用到了 外部引入的一个 time.js 包，通过调用其中的 **`getChatTime`** 方法，传入一个当前聊天信息发布时间与 前一条聊天信息的发布时间，来判断 **两条信息的时间间隔** 是否过长，满足条件返回当前信息的 发布时间，否则什么都不返回。

**`my-chat-item.vue`**

```html
<template>
	<view>
		<!-- 时间显示 -->
		<view v-if="computeShowTime" class="flex align-center justify-center pb-4">
			<text class="font-sm text-hover-light">{{computeShowTime}}</text>
		</view>
        ...
	</view>
</template>
<script>
  export default {
      ...
			props:{
                ...
				// 上一条消息的时间戳
				preTime:{
					type:Number|String,
				}
			},
			computed:{
                ...
				// 显示的时间
				computeShowTime(){
					// getChatTime 的作用：当相邻两条聊天数据 过近时，则不会返回数据。否则将返回当前聊天数据的发布时间。
					return $T.getChatTime(this.item.create_time,this.preTime)
				}
			},
    }
</script>
```

**`chat.nvue`**

此处若为第一条数据，则直接返回0，间接表示第一条数据中的 聊天时间是肯定会显示出来的

```html
<block v-for="(item,index) in list" :key="index">
	<myChatItem :item="item" :index="index" :preTime="index>0?list[index-1].create_time:0"></myChatItem>
</block>
```

## 长按弹出操作菜单（一）

**`chat.nvue`** 中弹出操作菜单的写法与 **`index.nvue`**类似。

首先，在 **`my-chat-item.vue`** 最外层元素绑定一个 长按事件，通过事件元素获取到用户点击的信息，传递给父组件：

```html
<template>
	<!-- 此处需要改为 div ,否则无法监听到 loadpress时间 -->
	<div @longpress="onLongPress">
		...
	</div>
</template>

<script>
  export default {
			methods:{
				// 长按事件
				onLongPress(e){
					let x = 0;
					let y = 0;
					// #ifdef APP-NVUE
					if(Array.isArray(e.changedTouches)&&e.changedTouches.length>0){
						x = e.changedTouches[0].screenX
						y = e.changedTouches[0].screenY
					}
					// #endif
					// #ifdef MP
					x = e.changedTouches[0].clientX
					y = e.changedTouches[0].clientY
					// #endif
					this.$emit('loadLongPress',{x,y,index:this.index})
				}
			}
    }
</script>
```

然后在使用到其的地方 **`chat.nvue`** 中监听这个事件，并在对应回调中展示弹出层：

```html
<template>
	<view>
        ...
		<!-- 聊天内容区域 -->
		<scroll-view scroll-y class="px-3 position-fixed bg-light left-0 right-0" style="bottom:105rpx" :style="'top:'+navBarHeight+'px'">			
			<block v-for="(item,index) in list" :key="index">
				<myChatItem :item="item" :index="index" :preTime="index>0?list[index-1].create_time:0" @loadLongPress="showLongPress"></myChatItem>
			</block>
		</scroll-view>
        ...
		<!-- 弹出层 -->
		<myPopup ref="popUp" :popHeight="computeMenuHeight" :popWidth="200" :index="propIndex">
			<view class="flex flex-column" style="width: 200rpx;" :style="computeMenuStyle">
				<!-- 此处加 flex-1 ，使得子元素可以均分父元素的的空间 -->
				<view class="flex-1 flex align-center" hover-class="bg-hover-light" v-for="(item,index) in menus" :key="index">
					<text class="font-md pl-2">{{item.name}}</text>
				</view>
			</view>
		</myPopup>
	</view>
</template>
<script>
	export default {
        data() {
			return {
				propIndex:-1,
				menus:[
					{
						name:'取消置顶',
						event:'setTop'
					},
					{
						name:'删除该聊天',
						event:'delChat'
					}
				],
		methods: {
			// 长按消息气泡
			showLongPress({x,y,index}){
				// 初始化索引
				this.propIndex = index
				// 显示扩展菜单
				this.$refs.popUp.show(x,y)
			}
		},
		computed:{
			// 动态获取菜单的高度
			computeMenuHeight(){
				let H = 100
				return this.menus.length * H
			},
			// 获取菜单的样式
			computeMenuStyle(){
				return `height:${this.computeMenuHeight}rpx`
			}
		}
	}
</script>
```

## 长按弹出操作菜单（二）

在 **`chat.nvue`** 中 由于底部输入框存在，当我们长按弹出操作菜单时，操作菜单会覆盖底部输入框。

要解决这个问题，就需要我们为  **`my-pop.vue`** 多传递一个 底部输入框的高度，并在计算 maxHeight 时，再减去这个 高度。

```html
<script>
export default {
	props: {
        ...
		// 底部输入框高度
		tabbarHeight:{
			type:Number,
			default:0
		}
	},
    methods: {
		show(x = -1, y = -1) {
			console.log('show')
			this.x = x > this.maxWidth ? this.maxWidth:x;
			this.y = y > this.maxHeight ? this.maxHeight:y;
			this.status = true;
			// #ifdef APP-NVUE
			// 此处要加 $nextTick，确保在 dom 树渲染完成后，再为其添加animation 动画
			this.$nextTick(function(){
				animation.transition(this.$refs.popup, {
				    styles: {
				        transform:'scale(1,1)',
								transformOrigin:this.transformOrigin,
				        opacity:1
				    },
				    duration: 300, //ms
				    timingFunction: 'ease',
				    }, function () {
				        console.log('成功')
				    })
			})
			// #endif
		},
        ...
	},
	mounted() {
		// 在 mounted 中为 maxWidth 和 maxHeight 赋值
		const res = uni.getSystemInfoSync();
		this.maxWidth = res.windowWidth - uni.upx2px(this.popWidth)
		this.maxHeight = res.windowHeight - uni.upx2px(this.popHeight) - uni.upx2px(this.tabbarHeight)
	},
    ...
};
</script>
```

在 **`chat.nvue`** 中使用：

```html
<!-- 弹出层 -->
<!-- 此处的 tabbarHeight 为我们定义的 底部输入框的高度 -->
<myPopup ref="popUp" :popHeight="computeMenuHeight" :popWidth="200" :index="propIndex" :tabbarHeight="105">
    <view class="flex flex-column" style="width: 200rpx;" :style="computeMenuStyle">
        <!-- 此处加 flex-1 ，使得子元素可以均分父元素的的空间 -->
        <view class="flex-1 flex align-center" hover-class="bg-hover-light" v-for="(item,index) in menus" :key="index">
            <text class="font-md pl-2">{{item.name}}</text>
        </view>
    </view>
</myPopup>
```

## 长按弹出操作菜单（三）

关于弹出操作菜单，我们还需要保证 当点击本人的信息时，操作菜单包含 撤回选项，而 当点击 好友 的信息时，不应该包含这个选项。这就需要我们 首先 设计一个可以判断 点击消息 的所属人的方法，再根据这个所属人去决定 是否要过滤 原先的操作菜单数组。

**chat.nvue**

```html
<template>
	<view>
        ...
		<!-- 弹出层 -->
		<myPopup ref="popUp" :popHeight="computeMenuHeight" :popWidth="200" :index="propIndex" :tabbarHeight="105">
			<view class="flex flex-column" style="width: 200rpx;" :style="computeMenuStyle">
				<!-- 此处加 flex-1 ，使得子元素可以均分父元素的的空间 -->
				<view class="flex-1 flex align-center" hover-class="bg-hover-light" v-for="(item,index) in computeMenus" :key="index">
					<text class="font-md pl-2">{{item.name}}</text>
				</view>
			</view>
		</myPopup>
	</view>
</template>
<script>
	export default {
        ...
		computed:{
            ...
			// 判断是否为本人信息
			computeIsSelf(){
				// 获取本人id （假设拿到了）
				let id = 1
            	 // 此处判断 propIndex 的操作个人认为可以省略，因为触发此方法时，已经调用了加载弹出框的方法，this.propIndex 已经确保有值了.
            	 // 但不排除接下来还需要在其他地方使用到这个方法，所以可以先写。
				let user_id = this.propIndex > -1 ? this.list[this.propIndex].user_id : 0
				return user_id === id
			},
			// 获取判断后的用户操作菜单
			computeMenus(){
				return this.menus.filter(menu=>{
					if(menu.name === '撤回' && !this.computeIsSelf){
						return false
					}else{
						return true
					}
				})
			}
		}
	}
</script>
```

## 消息撤回功能实现（一）

消息撤回实际上就是用 消息撤回 的提示信息来代替原先的 聊天气泡。而要实现手动消息撤回，就需要我们 为每个消息字段添加一个 用于判断消息是否撤回的字段。 通过点击操作菜单的 撤回 选项后修改 当前选中项 的这个字段，来实现 消息撤回的功能。

**`my-chat-item.vue`**

```html
<template>
	<!-- 此处需要改为 div ,否则无法监听到 loadpress时间 -->
	<div @longpress="onLongPress">
        ...
		<!-- 撤回消息 -->
		<view v-if="item.isremove" class="flex align-center justify-center pb-4 pt-1">
			<text class="font-sm text-hover-light">你撤回了一条信息</text>
		</view>
        <!-- 气泡 -->
		<view v-else class="flex align-start position-relative mb-3" :class="computeIsSelf?'justify-end':''">
            ...
		</view>
	</div>
</template>


<script>
  export default {
			props:{
				item:{
					type:Object,
					default:{}
				},
				index:{
					type:Number|String,
					required:true
				},
                ...
			},
      ...
    }
</script>
```

**`chat.nvue`**

```html
<template>
	<view>
        ...
		<!-- 弹出层 -->
		<myPopup ref="popUp" :popHeight="computeMenuHeight" :popWidth="200" :index="propIndex" :tabbarHeight="105">
			<view class="flex flex-column" style="width: 200rpx;" :style="computeMenuStyle">
				<view class="flex-1 flex align-center" hover-class="bg-hover-light" v-for="(item,index) in computeMenus" :key="index" @click="clickEvent(item.event)">
					<text class="font-md pl-2">{{item.name}}</text>
				</view>
			</view>
		</myPopup>
	</view>
</template>
<script>
	export default {
		data() {
			return {
                menus:[
					...
					{
						name:'撤回',
						event:'removeChatItem'
					},
					...   
				],
				list:[{
					avatar:"/static/images/demo/demo.jpg",
					user_id:1,
					type:'text',		// image,audio,video,file....
					data:"你好你好你好你好好好好好哦啊哈哦啊后111111111111",
					create_time:1635665516,
					isremove:true
				},{
					avatar:"/static/images/demo/demo.jpg",
					user_id:1,
					type:'text',		// image,audio,video,file....
					data:"你好你好你好你好",
					create_time:1635666666,
					isremove:false
				},
				]
			}
		},
		methods: {
			// 操作菜单方法分发
			clickEvent(event){
				switch (event){
					case 'removeChatItem':	// 撤回消息
						// 拿到当前被操作的信息
						this.list[this.propIndex].isremove = true
						break;
				}
				// 关闭菜单
				this.$refs.popUp.hide()
			}
            ...
		},
        ...
	}
</script>
```

## 消息撤回功能实现（二）

由于现在当我们撤回消息时，消息撤回的提示会直接闪出，显得很突兀。所以我们可以为消息撤回的view中其添加一个 opacity:0，之后监听 isrender 属性，如果改变，且为 true 时，触发动画，将其的 opacity变为1。

**`my-chat-item.vue`**

```html
<template>
	<div @longpress="onLongPress">
		<!-- 撤回消息 -->
		<view v-if="item.isremove" ref="isRemove" class="flex align-center justify-center pb-4 pt-1 chat-animate">
			<text class="font-sm text-hover-light">你撤回了一条信息</text>
		</view>
	</div>
</template>
<script>
  export default {
      ...
			mounted(){
				// 监听是否撤回消息
				// #ifdef APP-NVUE
				this.$watch('item.isremove',(newVal,oldVal)=>{
					if(newVal){
						const animation = weex.requireModule('animation')
						this.$nextTick(function(){
							animation.transition(this.$refs.isRemove, {
							    styles: {
							        opacity:1
							    },
							    duration: 100, //ms
							    timingFunction: 'ease',
							    }, function () {
							        console.log('成功')
							    })
						})
					}
				})
				// #endif
			},
    }
</script>
<style scoped>
.chat-animate{
	/* #ifdef APP-NVUE */
	opacity:0
	/* #endif */
}
</style>
```

<div class="danger">

> 注意：此时这种设置情况会导致当有消息一开始就是撤回状态的时候无法显示，关于这个问题，我们之后再处理。

</div>

## 解决键盘顶起窗口的问题

此时当我们在聊天页面用输入框输入内容时，弹起的输入框会将整个窗口顶起。而要解决这个问题：

首先我们需要为 textarea 设置 **adjust-position** 为false ，确保当键盘弹起时，不会自动上推页面。但此时键盘仍然会将输入框遮盖。

原因是因为输入框的 **bottom** 固定，而我们此时要做的，就是在 mounted 中使用 **uni.onKeyboardHeightChange**  来监听键盘的升起操作，并将 回调中的 res.height 保存，并赋值给 输入框的 **`bottom`** 。

最后还有一个问题：由于聊天页面的 bottom 也是固定的。所以我们当键盘弹起时会被遮盖，所以我们也得为其添加一个 计算后的 bottom。

**`chat.nvue`**

```html
<template>
	<view>
        ...
		<!-- 聊天内容区域 -->
		<scroll-view scroll-y class="px-3 position-fixed bg-light left-0 right-0" style="bottom:105rpx" :style="chatBodyStyle" :show-scrollbar="false">	
            ...
		</scroll-view> 
		<!-- 底部输入框 -->
		<view class="position-fixed flex align-center left-0 right-0 border-top" style="background-color: #F7F7F6;height: 105rpx;" :style="'bottom:' + keyboardHeight + 'px;'">
            ...
		</view>
	</view>
</template>
<script>
	export default {
        ...
		mounted(){
        ...
			// 监听键盘高度变化
			uni.onKeyboardHeightChange(res => {
			  this.keyboardHeight = res.height
			})
		},
		computed:{
            ...
			// 聊天区域 bottom 及 top
			chatBodyStyle(){
				const top = `top:${this.navBarHeight}px;`
				return `bottom:${uni.upx2px(150)}px;${top}`
			}
		}
	}
</script>
```

## 滚动到底部功能实现

本节实现当我们升起 键盘时，将聊天内容划至最底部的功能。

主要是依靠 weex 的一个 **`dom.scrollToElement`** 来实现本功能。

**`chat.nvue`**

```html
<template>
	<view>
        ...
		<!-- 聊天内容区域 -->
		<scroll-view scroll-y class="px-3 position-fixed bg-light left-0 right-0" style="bottom:105rpx" :style="chatBodyStyle" :show-scrollbar="false">			
			<block v-for="(item,index) in list" :key="index">
				<myChatItem ref="chatItem" :item="item" :index="index" :preTime="index>0?list[index-1].create_time:0" @loadLongPress="showLongPress"></myChatItem>
			</block>
		</scroll-view> 
        ...
	</view>
</template>
<script>
	// #ifdef APP-NVUE
	const dom = weex.requireModule('dom')
	// #endif
	export default {
		mounted(){
            ...
			// 监听键盘高度变化
			uni.onKeyboardHeightChange(res => {
			  this.keyboardHeight = res.height
				if(this.keyboardHeight>0){
					this.pageToBottom()
				}
			})
		},
		methods: {
            ...
			// 聊天页回到底部
			pageToBottom(){
				// #ifdef APP-NVUE
				const chatItems = this.$refs.chatItem
				const lastIndex = chatItems.length > 0 ? chatItems.length - 1 : -1
				if(lastIndex !== -1){
					dom.scrollToElement(chatItems[lastIndex],{})
				}
				// #endif
			}
		},
	}
</script>
```

## 发送文字功能实现

为了实现文字发送功能，

首先我们得 创建一个发送图标，并保证在输入框有内容时显示，没内容时则显示扩展图标。

然后监听按钮点击事件，判断 事件类型，当时 **text** 类型时，表示发送文字内容。那我们便可新建一个 气泡对象，并 push 到气泡数组中。

最后要保证当输入新内容后，会将聊天框滚动回页面底部。

**`chat.nvue`**

```html
<template>
	<view>
        ...
		<!-- 底部输入框 -->
		<view class="position-fixed flex align-center left-0 right-0 border-top" style="background-color: #F7F7F6;height: 105rpx;" :style="'bottom:' + keyboardHeight + 'px;'">
            ...
            <view class="flex-1">
				<textarea v-model="text" adjust-position="false" fixed class="bg-white rounded p-1 font-md" style="height: 75rpx;"/>
			</view>
            ...
			<!-- 扩展菜单按钮与发送按钮 2选1 -->
			<!-- 扩展菜单按钮 -->
			<myIconButton v-if="!this.text" :icon="'\ue726'"></myIconButton>
			<!-- 发送按钮 -->
			<view v-else class="main-bg-color rounded mr-3 px-2 py-1" @click="send('text')">
				<text class="font text-white">发送</text>
			</view>
		</view>
	</view>
</template>
<script>
	// #ifdef APP-NVUE
	const dom = weex.requireModule('dom')
	// #endif
	export default {
		data() {
			return {
                ...
				text:'',	// 输入文字
			}
		},
		methods: {
            ...
			// 发送（发送的信息可能有多种类型）
			send(type){
				let obj = {
					avatar:"/static/images/demo/demo.jpg",
					user_id:1,
					nickname:'昵称',
					type:type,		// image,audio,video,file....
					data:this.text,
					create_time:(new Date()).getTime(),
					isremove:false
				}
				switch(type){
					case 'text': 
						obj.data = this.text
						break;
				}
				this.list.push(obj)
				if(type==='text'){
					this.text = ''
				}
				// 置于底部
				// #ifdef APP-NVUE
				this.$nextTick(function(){
					this.pageToBottom()
				})
				// #endif
			},
			// 聊天页回到底部
			pageToBottom(){
				// #ifdef APP-NVUE
				const chatItems = this.$refs.chatItem
				const lastIndex = chatItems.length > 0 ? chatItems.length - 1 : -1
				if(lastIndex !== -1){
					dom.scrollToElement(chatItems[lastIndex],{})
				}
				// #endif
				console.log(lastIndex,chatItems.length,123456)
			},
		},
        ...
	}
</script>
```

## 底部操作菜单开发（一）

本节主要来实现底部操作菜单的隐藏显示功能

要实现隐藏显示，首先得 有操作菜单，所以我们得定义一个 新的 myPopup，并为其添加 fixedBottom 属性，让其从底部出现。

当点击 扩展按钮时 ，触发点击事件显示操作菜单，这时不仅要 调用 show 方法，还得 修改 keyboardHeight，让底部输入框得以弹起。

而要隐藏操作菜单，需要 myPopup 的配合，当我们 触发其的 hide 方法时，触发父组件的 hide ，进而将 keyboardHeight 重置为0。

**`myPopup.vue`**

```html
<script>
export default {
    ...
	methods: {
        ...
		hide() {
			console.log('hide')
			// #ifdef APP-NVUE
			this.$nextTick(function(){
				animation.transition(this.$refs.popup, {
				    styles: {
				        transform:'scale(0,0)',
								transformOrigin:this.transformOrigin,
				        opacity:0
				    },
				    duration: 300, //ms
				    timingFunction: 'ease',
				    }, () =>{
				        this.status = false
				    })
			})
			// #endif
			// #ifndef APP-NVUE
			this.status = false
			// #endif
			uni.$emit(`changeHover${this.index}`)
			this.$emit('hide')
		},
	},
};
</script>
```

**`chat.nvue`**

```html
<template>
	<view>
        ...
		<!-- 底部扩展菜单 -->
		<myPopup ref="action" fixedBottom transformOrigin="center bottom" @hide="keyboardHeight=0">
			<view style="height: 580rpx;">
				123456
			</view>
		</myPopup>
	</view>
</template>
<script>
	export default {
        ...
		methods: {
            ...
			// 打开扩展菜单
			openExtension(){
				this.$refs.action.show()
				this.keyboardHeight = uni.upx2px(580)
			},
		},
	}
</script>
```



暂时学到这里，感觉bug 过多.....



