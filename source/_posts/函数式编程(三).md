---
title: 函数式编程(三)
tags:
  - JavaScript
categories:
  - 大前端
  - JavaScript
abbrlink: 77d68bd7
date: 2021-09-29 19:44:28
---



## 函数组合

- 纯函数和柯里化很容易写出洋葱代码 h(g(f(x)))
  - 获取数组的最后一个元素再转换成大写字母，\_.toUpper(\_.first(\_.reverse(array)))

![](函数式编程(三)/1.png)

- 函数组合可以让我们把细粒度的函数组合生成一个新的函数

### 管道的理解

&emsp;&emsp;下面这张图表示程序中使用函数处理数据的过程，给 fn 函数输入参数 a，返回结果 b。可以想想 a 数据 通过一个管道得到了 b 数据。

![](函数式编程(三)/2.png)

&emsp;&emsp;当 fn 函数比较复杂的时候，我们可以把函数 fn 拆分成多个小函数，此时多了中间运算过程产生的 m 和 n。 下面这张图中可以想象成把 fn 这个管道拆分成了3个管道 f1, f2, f3，数据 a 通过管道 f3 得到结果 m，m 再通过管道 f2 得到结果 n，n 通过管道 f1 得到最终结果 b。

![](函数式编程(三)/3.png)

```javascript
fn = compose(f1, f2, f3)
b = fn(a)
```

### 函数组合

- 函数组合 (compose)：如果一个函数要经过多个函数处理才能得到最终值，这个时候可以**把中间过程的函数合并成一个函数**
  - 函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果 
  - 函数组合默认是从右到左执行（f3->f2->f1）

```javascript
// 函数组合演示
function compose(f, g) {
    return function (value) {
        return f(g(value))
    }
}

function reverse(array) {
    return array.reverse()
}

function first(array) {
    return array[0]
}

const last = compose(first, reverse)

console.log(last([1, 2, 3, 4]))
```



## Lodash中的组合函数

- lodash 中组合函数 flow() 或者 flowRight()，他们都可以组合多个函数

  - flow() 是从左到右运行

  - flowRight() 是从右到左运行，使用的更多一些

```javascript
// lodash 中的函数组合的方法 _.flowRight()
const _ = require('lodash')

const reverse = arr => arr.reverse()
const first = arr => arr[0]
const toUpper = s => s.toUpperCase()

const f = _.flowRight(toUpper, first, reverse)
console.log(f(['one', 'two', 'three']))
```

## 组合函数的实现原理(重点!!!)

```javascript
// lodash 中的函数组合的方法 _.flowRight()
const _ = require('lodash')

const reverse = arr => arr.reverse()
const first = arr => arr[0]
const toUpper = s => s.toUpperCase()


// function compose(...args) {
//     return function (value) {
//         return args.reverse().reduce(function (acc, fn) {
//             return fn(acc)
//         }, value)
//     }
// }

// 注意，当写成函数赋值的形式时，不会变量提升
const compose = (...args) => value => args.reverse().reduce((acc, fn) => fn(acc), value)

const f = compose(toUpper, first, reverse)
console.log(f(['one', 'two', 'three']))
```



## 函数组合-结合律

- 函数的组合要满足**结合律**
  - 我们既可以把 g 和 h组合，还可以把 f 和 g 组合，结果都是一样的

```javascript
// 结合律（associativity）
let f = compose(f, g, h)
let associative = compose(compose(f, g), h) == compose(f, compose(g, h))	// true
```



- 案例

```javascript
// 函数组合要满足结合律
const _ = require('lodash')

const f = _.flowRight(_.flowRight(_.toUpper, _.first), _.reverse)
const f2 = _.flowRight(_.toUpper, _.flowRight(_.first, _.reverse))
console.log(f(['one', 'two', 'three']))     // THREE
console.log(f2(['one', 'two', 'three']))    // THREE
```



## 函数组合的调试

```javascript
// 函数组合 调试
// NEVER SAY DIE --> never-say-die

const _ = require('lodash')

// _.split()    split有多个参数，不适合函数组合，不考虑直接使用
const split = _.curry((sep, str) => _.split(str, sep))

// _.toLower()

const join = _.curry((sep, array) => _.join(array, sep))

// const log = v => {      // 通过定义这个log函数，并插入到flowRgiht中，使得运行过程中的结果可以被输出看到。
//     console.log(v)
//     return v
// }

// const f = _.flowRight(join('-'), log, _.toLower, split(' '))

// 对log进一步修改，使得可以知道是在哪个函数之后打印的
const trace = _.curry((fnName, v) => {
    console.log(fnName, v)
    return v
})

const map = _.curry((fn, array) => {
    return _.map(array, fn)
})
// 修改版
const f = _.flowRight(join('-'), trace('map 之后'), map(_.toLower), trace('split 之后'), split(' '))


console.log(f('NEVER SAY DIE'))     // 此处的NEVER SAY DIE就相当于split的第二个参数
```

![](函数式编程(三)/4.png)

## Lodash-fp模块

- lodash 的 fp 模块提供了实用的对函数式编程友好的方法 
- 提供了不可变 **auto-curried iteratee-first data-last** （自动柯里化，函数优先，数据滞后）的方法

```javascript
// lodash 模块（数据优先，函数滞后）
const _ = require('lodash')
_.map(['a', 'b', 'c'], _.toUpper)
// => ['A', 'B', 'C']
_.map(['a', 'b', 'c'])
// => ['a', 'b', 'c']
_.split('Hello World', ' ')


// lodash/fp 模块（自动柯里化，函数优先，数据滞后）
const fp = require('lodash/fp')
fp.map(fp.toUpper, ['a', 'b', 'c'])
fp.map(fp.toUpper)(['a', 'b', 'c'])
fp.split(' ', 'Hello World')
fp.split(' ')('Hello World')
```



```javascript
// lodash的 fp 模块
// NEVER SAY DIE --> never-say-die

// 使用lodash的写法
// const _ = require('lodash')

// const split = _.curry((sep, str) => _.split(str, sep))
// const join = _.curry((sep, array) => _.join(array, sep))
// const map = _.curry((fn, array) => _.map(array, fn))

// const f = _.flowRight(join('-'), map(_.toLower), split(' '))

// 使用lodash/fp的写法
const fp = require('lodash/fp')

const f = fp.flowRight(fp.join('-'), fp.map(fp.toLower), fp.split(' '))

console.log(f('NEVER SAY DIE'))
```

## Lodash-map方法的小问题

```javascript
// lodash 和 lodash/fp 模块中 map 方法的区别
// const _ = require('lodash')

// map函数执行时会给第二个参数函数传递三个参数，分别是当前遍历的值、当前值的索引以及遍历的数组
// console.log(_.map(['23', '8', '10'], parseInt))     // [ 23, NaN, 2 ]

// 模拟map函数执行过程：
// parseInt('23' , 0 , array)       // parseInt的第二个参数为进制数2-36。若传0，则转换为10进制，若为1，则传回NaN
// parseInt('8' , 1 , array)
// parseInt('10' , 2 , array)       // 10转换为2进制为2
// 由于map给parseInt的传参及parseInt的参数规则，最终导致出现了 [ 23, NaN, 2 ] 的结果

const fp = require('lodash/fp')

// lodash/fp 中的map的第一个参数为函数，这个函数只有一个参数，即遍历的值。
console.log(fp.map(parseInt, ['23', '8', '10']))
```



## PointFree

- Point Free：我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参 数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。
  - 不需要指明处理的数据 
  - 只需要合成运算过程 
  - 需要定义一些辅助的基本运算函数

```javascript
const f = fp.flowRight(fp.join('-'), fp.map(_.toLower), fp.split(' '))
```

```javascript
// point free
// Hello   World => hello_world
const fp = require('lodash/fp')

const f = fp.flowRight(fp.replace(/\s+/g, '_'), fp.toLower)

console.log(f('Hello   World'))
```

- 案例

```java
// 把一个字符串中的首字母提取并转换成大写，使用. 作为分隔符
// world wild web ==> W. W. W
const fp = require('lodash/fp')

// const firstLetterToUpper = fp.flowRight(fp.join('. '), fp.map(fp.first), fp.map(fp.toUpper), fp.split(' ')) // 此处对数组做了两次循环，会导致性能变低
const firstLetterToUpper = fp.flowRight(fp.join('. '), fp.map(fp.flowRight(fp.first(), fp.toUpper())), fp.split(' '))

console.log(firstLetterToUpper('world wild web'))
```



