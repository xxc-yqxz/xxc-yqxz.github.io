---
title: 函数式编程(四)
abbrlink: 8d9564d8
date: 2021-09-30 16:18:18
tags:
  - JavaScript
categories:
  - 大前端
  - JavaScript
---

## Functor(函子)

> 为什么要学习函子？

到目前为止已经学习了函数式编程的一些基础，但是我们还没有演示在函数式编程中如何把副作用控制在可控的范围内、异常处理、异步操作等。

> 什么是Functor

- 容器：包含值和值的变形关系(这个变形关系就是函数) 
- 函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有 map 方法，map 方法可以运行一个函数对值进行处理(变形关系)

```javascript
// Functor 函子
// 函子是一个具有map方法的对象，在函子中要维护一个值，这个值永远不对外公布。而是通过调用map方法来传入一个处理值的函数,map方法处理完后返回一个新的函子
// class Container {
//     constructor(value) {
//         this._value = value
//     }
//     map(fn) {
//         return new Container(fn(this._value))
//     }
// }

// let r = new Container(5)
//     .map(x => x + 1)
//     .map(x => x * x)

// console.log(r)

// 上面的写法需要不停的new Container。所以可以改写为如下写法
class Container {
    static of(value) {
        return new Container(value)
    }

    constructor(value) {
        this._value = value
    }
    map(fn) {
        return Container.of(fn(this._value))
    }
}

let r = Container.of(5)
    .map(x => x + 2)
    .map(x => x * x)

console.log(r)
```

- 函子总结
  - 函数式编程的运算不直接操作值，而是由函子完成 
  - 函子就是一个实现了 map 契约的对象 
  - 我们可以把函子想象成一个盒子，这个盒子里封装了一个值 
  - 想要处理盒子中的值，我们需要给盒子的 map 方法传递一个处理值的函数（纯函数），由这 个函数来对值进行处理 
  - 最终 map 方法返回一个包含新值的盒子（函子）

## MayBe函子

```javascript
// 演示 null undefined 的问题
Container.of(null)		// 此时出现异常，没有输出，故其变得不纯
    .map(x => x.toUpperCase())
```

- 我们在编程的过程中可能会遇到很多错误，需要对这些错误做相应的处理 
- MayBe 函子的作用就是可以对外部的空值情况做处理（控制副作用在允许的范围）

```javascript
// MayBe函子 
class MayBe {
    static of(value) {
        return new MayBe(value)
    }
    constructor(value) {
        this._value = value
    }
    map(fn) {
        return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this._value))
    }
    isNothing() {
        return this._value === null || this._value === undefined
    }
}

// let r = MayBe.of('Hello World')
//     .map(x => x.toUpperCase())
// console.log(r)

// let r = MayBe.of(null)
//     .map(x => x.toUpperCase())
// console.log(r)   // null

// 下方代码的结果说明，MayBe函子无法明确指明是在何处输出null
let r = MayBe.of('hello world')
    .map(x => x.toUpperCase())
    .map(x => null)
    .map(x => x.split)
console.log(r)
```

## Either 函子

- Either 两者中的任何一个，类似于 if...else...的处理 
- 异常会让函数变的不纯，Either 函子可以用来做异常处理

```javascript
// Either函子
class Left {
    static of(value) {
        return new Left(value)
    }

    constructor(value) {
        this._value = value
    }

    map(fn) {
        return this
    }
}

class Right {
    static of(value) {
        return new Right(value)
    }

    constructor(value) {
        this._value = value
    }

    map(fn) {
        return Right.of(fn(this._value))
    }
}

// let r1 = Right.of(12).map(x => x + 2)
// let r2 = Left.of(12).map(x => x + 2)

// console.log(r1)
// console.log(r2)

// 准备一个普通的函子Right，及一个map直接输出传入的数据的函子Left，来进行trycatch处理，即为Either函子
function parseJSON(str) {
    try {
        return Right.of(JSON.parse(str))
    } catch (e) {
        return Left.of({ error: e.message })
    }
}

// let r = parseJSON('{name:zs}')
// console.log(r)

let r = parseJSON('{"name":"zs"}')
    .map(x => x.name.toUpperCase())
console.log(r)
```

## IO函子

- IO 函子中的 _value 是一个函数，这里是把函数作为值来处理 
- IO 函子可以把不纯的动作存储到 _value 中，延迟执行这个不纯的操作(惰性执行)，包装当前的操作 
- 把不纯的操作交给调用者来处理

```javascript
// IO函子
const fp = require('lodash/fp')

class IO {
    static of(value) {
        return new IO(function () {
            return value
        })
    }
    constructor(fn) {
        this._value = fn
    }
    map(fn) {
        // IO函子的map不是直接返回函数处理后的结果，而是返回一个组合函数
        return new IO(fp.flowRight(fn, this._value))
    }
}

// 调用
let r = IO.of(process).map(p => p.execPath) // 此处的map中的函数不纯，但是我们执行map方法时始终会返回一个纯的函子。我们通过IO函子将副作用延迟到了调用的时候
// console.log(r)
console.log(r._value())
```

## folkTale.js

- 异步任务的实现过于复杂，我们使用 folktale 中的 Task 来演示 
- [folktale](https://folktale.origamitower.com/docs/v2.3.0/) 一个标准的函数式编程库
  - 和 lodash、ramda 不同的是，他没有提供很多功能函数，只提供了一些函数式处理的操作，例如：compose、curry 等，
  - 一些函子 Task、Either、 MayBe 等

```javascript
// folktale 中的compose、curry
const { compose, curry } = require('folktale/core/lambda')
const { toUpper, first } = require('lodash/fp')
// curry的第一个参数为了说明第二个参数函数有几个参数，效果相当于lodash中的curry
// let f = curry(2, (x, y) => {
//     return x + y
// })

// console.log(f(1, 2))
// console.log(f(1)(2))

// compose用于组合函数，效果相当于lodash中的flowRight
let f = compose(toUpper, first)
console.log(f(['one', 'two']))
```

### Task函子执行异步任务

```javascript
// Task 处理异步任务
const fs = require('fs')
const { task } = require('folktale/concurrency/task')
const { split, find } = require('lodash/fp')

function readFile(filename) {
    return task(resolver => {
        fs.readFile(filename, 'utf-8', (err, data) => {
            if (err) resolver.reject(err)

            resolver.resolve(data)
        })
    })
}

readFile('../../package.json')
    .map(split('\n'))
    .map(find(x => x.includes('version')))
    .run()
    .listen({
        onRejected: err => {
            console.log(err)
        },
        onResolved: value => {
            console.log(value)
        }
    })
```

## Pointed函子

- Pointed函子指的是实现了 of 静态方法的函子
- of 方法是为了避免使用new 来创建对象，更深层的含义是 of 方法用来把值放到上下文 Context ，将来我们就可以在上下文中来处理这个数据（把值放到容器中，使用map来处理值）

![](函数式编程(四)/1.png)

![](函数式编程(四)/2.png)

```javascript
class Container {
static of (value) {
	return new Container(value)
}
……
}
Contanier.of(2)
	.map(x => x + 5)
```

## Monad函子

### IO函子问题

> 当使用嵌套函子时，我们需要._value()、._value()来调用函子中的函数，这样很麻烦

```javascript
// IO函子
const fs = require('fs')
const fp = require('lodash/fp')

class IO {
    static of(value) {
        return new IO(function () {
            return value
        })
    }
    constructor(fn) {
        this._value = fn
    }
    map(fn) {
        return new IO(fp.flowRight(fn, this._value))
    }
}

let readFile = function (filename) {
    return new IO(function () {
        return fs.readFileSync(filename, 'utf-8')
    })
}

let print = function (x) {
    return new IO(function () {
        console.log(x)
        return x
    })
}

let cat = fp.flowRight(print, readFile) // IO(IO(x))

let r = cat('../../package.json')._value()._value()
console.log(r)
```

- Monad 函子是可以变扁的 Pointed 函子
- IO(IO(x)) 一个函子如果具有 join 和 of 两个方法并遵守一些定律就是一个 Monad

```javascript
// IO monad
const fs = require('fs')
const fp = require('lodash/fp')

class IO {
    static of(value) {
        return new IO(function () {
            return value
        })
    }
    constructor(fn) {
        this._value = fn
    }
    map(fn) {
        return new IO(fp.flowRight(fn, this._value))
    }
    join() {
        return this._value()
    }

    flatMap(fn) {
        return this.map(fn).join()
    }
}

let readFile = function (filename) {
    return new IO(function () {
        return fs.readFileSync(filename, 'utf-8')
    })
}

let print = function (x) {
    return new IO(function () {
        console.log(x)
        return x
    })
}

let r = readFile('../../package.json')
    .map(fp.toUpper)
    .flatMap(print)
    .join()
console.log(r)
```

> 当合并的函数返回一个函子的时候，我们可以使用monad（具体是使用monad函子中的flatMap方法），monad可以帮我们解决函子嵌套的问题。