---
title: 函数式编程(二)
tags:
  - JavaScript
categories:
  - 大前端
  - JavaScript
abbrlink: 925abfc
date: 2021-09-29 15:16:04
---

## 纯函数

- 纯函数：**相同的输入永远会得到相同的输出**(需要有参数和返回值)，而且没有任何可观察的副作用
  - 纯函数就类似数学中的函数(用来描述输入和输出之间的关系)，y = f(x)

![](函数式编程(二)/1.png)

- lodash 是一个纯函数的功能库，提供了对数组、数字、对象、字符串、函数等操作的一些方法
- 数组的 slice 和 splice 分别是：纯函数和不纯的函数
  - slice 返回数组中的指定部分，不会改变原数组 
  - splice 对数组进行操作返回该数组，会改变原数组

```javascript
// 纯函数和不纯的函数
// slice / splice

let array = [1, 2, 3, 4, 5]

// 纯函数
console.log(array.slice(0, 3))  // [ 1, 2, 3 ]
console.log(array.slice(0, 3))  // [ 1, 2, 3 ]
console.log(array.slice(0, 3))  // [ 1, 2, 3 ]

// 不纯的函数
console.log(array.splice(0, 3)) // [ 1, 2, 3 ]
console.log(array.splice(0, 3)) // [ 4, 5 ]
console.log(array.splice(0, 3)) // []

// 纯函数
function getSum(n1, n2) {
    return n1 + n2
}
console.log(getSum(1, 2))   // 3
console.log(getSum(1, 2))   // 3
console.log(getSum(1, 2))   // 3
```

- 函数式编程不会保留计算中间的结果，所以变量是不可变的(无状态的)
- 我们可以把一个函数的执行结果交给另一个函数去处理

## Lodash

- Lodash 是一个一致性、模块化、高性能的 JavaScript 实用工具库。

[Lodash官网](https://www.lodashjs.com/)

```javascript
// 演示 lodash
// first / last / toUpper / reverse / each / includes / find / findIndex
const _ = require('lodash')

const array = ['jack', 'tom', 'lucy', 'kate']

console.log(_.first(array))
console.log(_.last(array))

console.log(_.toUpper(_.first(array)))

console.log(_.reverse(array))

const r = _.each(array, (item, index) => {
    console.log(item, index)
})

console.log(r)
```

## 纯函数的好处

- 可缓存

  - 因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来（避免要多次执行同一个函数得到其返回值，而影响性能）

    ```javascript
    // 记忆函数
    const _ = require('lodash')
    
    function getArea(r) {
        console.log(r)
        return Math.PI * r * r
    }
    
    let getAreaWithMemory = _.memoize(getArea)
    console.log(getAreaWithMemory(4))   // 只有第一次次调用getAreaWithMemory时会输出r，下面的两次都是直接输出缓存数据，而不会在调用getArea
    console.log(getAreaWithMemory(4))
    console.log(getAreaWithMemory(4))
    ```

    

  - 自己模拟一个memoize函数

    ```javascript
    function getArea(r) {
        console.log(r)
        return Math.PI * r * r
    }
    
    // 模拟 memoize 方法的实现，参数要求是纯函数
    function memoize(f) {
        let cache = {}
        return function () {
            let key = JSON.stringify(arguments)
            // 先判断缓存中是否有值，若有则赋值，若没有则执行f，并将返回值缓存
            cache[key] = cache[key] || f.apply(f, arguments)
            return cache[key]
        }
    }
    
    // 此处说明闭包使得函数内部的变量会一直存在于内存中，并不会立即释放，除非将引用改为null（getAreaWithMemory=null）。
    let getAreaWithMemory = memoize(getArea)
    console.log(getAreaWithMemory(4))   // 只有第一次次调用getAreaWithMemory时会输出r，下面的两次都是直接输出缓存数据，而不会在调用getArea
    console.log(getAreaWithMemory(4))
    console.log(getAreaWithMemory(4))
    ```

- 可测试
  
  - 纯函数让测试更方便(因为其肯定有输入输出)
- 并行处理
  - 在多线程环境下并行操作共享的内存数据很可能会出现意外情况
  - 纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数(ES6后有了Web Worker可开启多线程)



## 副作用的概念

- 纯函数：对于相同的输入永远会得到相同的输出，没有任何可观察的**副作用**

```javascript
// 不纯的（当mini改变时，checkAge的返回值也会改变）
let mini = 18
function checkAge (age) {
	return age >= mini
}
// 纯的(有硬编码，后续可以通过柯里化解决)
function checkAge (age) {
	let mini = 18
	return age >= mini
}
```

> 硬编码：将数据直接嵌入到程序或其他可执行对象的源代码中的软件开发实践，与从外部获取数据或在运行时生成数据不同。 

&emsp;&emsp;副作用让一个函数变的不纯(如上例)，纯函数的根据相同的输入返回相同的输出，如果函数依赖于外部 的状态就无法保证输出相同，就会带来副作用。

副作用来源：

- 配置文件
- 数据库
- 获取用户的输入
- .....

&emsp;&emsp;所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降不适合扩展和可重用性，同时副作用会给程序中带来安全隐患给程序带来不确定性，但是副作用不可能完全禁止，尽可能控制它们在可控范围内发生。

## 柯里化

- 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）

-  然后返回一个新的函数接收剩余的参数，返回结果

  

- 使用柯里化解决硬编码问题

```javascript
// 柯里化演示
// function checkAge(age) {
//     let min = 18
//     return age >= min
// }

// 普通的纯函数，没有硬编码问题
function checkAge(min, age) {
    return age >= min
}

// console.log(checkAge(18, 20))
// console.log(checkAge(18, 24))
// console.log(checkAge(22, 24))

// 函数的柯里化
// function checkAge(min) {
//     return function (age) {
//         return age >= min
//     }
// }

// ES6箭头函数
let checkAge = min => (age => age >= min)

let checkAge18 = checkAge(18)
let checkAge20 = checkAge(20)

console.log(checkAge18(20))
console.log(checkAge18(24))
```



## Lodash中的柯里化

- _.curry(func)

  - 功能：创建一个函数，该函数接收一个或多个 func 的参数，如果 func 所需要的参数都被提 供则执行 func 并返回执行的结果。否则继续返回该函数并等待接收剩余的参数。
  - 参数：需要柯里化的函数
  - 返回值：柯里化后的函数

  ```javascript
  // lodash 中的 curry基本使用
  const _ = require('lodash')
  
  function getSum(a, b, c) {
      return a + b + c
  }
  
  const curried = _.curry(getSum)
  
  console.log(curried(1, 2, 3))	// 6
  console.log(curried(1)(2, 3))	// 6
  console.log(curried(1)(2)(3))	// 6
  ```

## 柯里化案例

```javascript
// 柯里化案例
// ''.match(/\s+/g)     // 全局匹配所有空格
// ''.match(/\d+/g)     // 全局匹配所有数字

const _ = require('lodash')

const match = _.curry(function (reg, str) {
    return str.match(reg)
})

const haveSpace = match(/\s+/g)
const haveNumber = match(/\d+/g)

console.log(haveSpace('hello world'))   // [' ']
console.log(haveSpace('helloworld'))   // null

console.log(haveNumber('123abc'))   // ['123']
console.log(haveNumber('abc'))   // null

const filter = _.curry(function (func, array) {
    return array.filter(func)	// 此处比较难以理解，等价于：Array.filter(function(str){return str.match(reg)})
})

console.log(filter(haveSpace, ['JoinCCC', 'Join XXX']))

const findSpace = filter(haveSpace)
console.log(findSpace(['JoinCCC', 'Join XXX']))
```

## 柯里化实现原理

<div class="success">

> 此处curry函数的定义请好好参透

</div>

```javascript
// 模拟实现 lodash 中的 curry 方法

function getSum(a, b, c) {
    return a + b + c
}

const curried = curry(getSum)

console.log(curried(1, 2, 3))
console.log(curried(1)(2, 3))
console.log(curried(1)(2)(3))

// 可以通过函数名.length来获取函数的参数个数
// console.log(getSum.length)      // 3

function curry(func) {
    return function curriedFn(...args) { // 此处使用ES6剩余参数语法
        // 判断实参和形参的个数
        if (args.length < func.length) {
            return function () {
                // 此处使用Array.from将伪数组转为数组，再使用concat将两个数组连接，最后使用...来将数组解构
                return curriedFn(...args.concat(Array.from(arguments)))
            }
        }
        return func(...args)
    }
}
```



## 柯里化总结

- 柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数 
- 这是一种对函数参数的'缓存' 
- 让函数变的更灵活，让函数的粒度更小 
- 可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能