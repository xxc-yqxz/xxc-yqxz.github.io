<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#5698c3"><meta name="author" content="语轻星子"><meta name="copyright" content="语轻星子"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>LG—React基础回顾 | 轻语馆</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js" defer></script><script src="/js/pjax.js" defer></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="icon" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#5698c3"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"xxcijmz.top","root":"/","title":"轻语馆","version":"1.6.2","mode":"time","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"/data/sentences.json"},"algolia":{"appID":"I6Q6TFSWKC","apiKey":"8299a265813c86a465cc32755761abc9","indexName":"blogs","hits":{"per_page":10}}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="stylesheet" href="/css/content.css"><meta name="description" content="React 介绍 React 是一个用于构建用户界面的 JavaScript 库，它只负责应用的视图层，帮助开发人员构建快速且交互式的 web 应用程序。 React 使用组件的方式构建用户界面。（all in js：一切都使用javascript，构建用户界面的结构、样式、逻辑） JSX 语法在 React 中使用 JSX 语法描述用户界面，它是一种 JavaScript 语法扩展。 在 Rea">
<meta property="og:type" content="article">
<meta property="og:title" content="LG—React基础回顾">
<meta property="og:url" content="https://xxcijmz.top/blogs/1a53f83b/index.html">
<meta property="og:site_name" content="轻语馆">
<meta property="og:description" content="React 介绍 React 是一个用于构建用户界面的 JavaScript 库，它只负责应用的视图层，帮助开发人员构建快速且交互式的 web 应用程序。 React 使用组件的方式构建用户界面。（all in js：一切都使用javascript，构建用户界面的结构、样式、逻辑） JSX 语法在 React 中使用 JSX 语法描述用户界面，它是一种 JavaScript 语法扩展。 在 Rea">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xxcijmz.top/blogs/1a53f83b/1.jpg">
<meta property="og:image" content="https://xxcijmz.top/blogs/1a53f83b/2.gif">
<meta property="og:image" content="https://xxcijmz.top/blogs/1a53f83b/2.jpg">
<meta property="og:image" content="https://xxcijmz.top/blogs/1a53f83b/3.jpg">
<meta property="og:image" content="https://xxcijmz.top/blogs/1a53f83b/4.jpg">
<meta property="og:image" content="https://xxcijmz.top/blogs/1a53f83b/5.jpg">
<meta property="article:published_time" content="2021-12-20T10:58:12.000Z">
<meta property="article:modified_time" content="2021-12-20T14:53:33.388Z">
<meta property="article:author" content="语轻星子">
<meta property="article:tag" content="React">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xxcijmz.top/blogs/1a53f83b/1.jpg"><script src="/js/ui/mode.js"></script></head><body><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="语轻星子"><img width="96" loading="lazy" src="https://cdn.jsdelivr.net/gh/xxc-yqxz/xxc-yqxz.github.io/images/avatar.jpg" alt="语轻星子"></a><div class="site-author-name"><a href="/about/">语轻星子</a></div><span class="site-name">轻语馆</span><sub class="site-subtitle">我也会加油，所以你也要加油，这是约定</sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">48</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">17</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">18</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://github.com/xxc-yqxz/xxc-yqxz.github.io" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://wpa.qq.com/msgrd?v=3&amp;uin=894043590&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=1379764422" title="网易云音乐" target="_blank" style="color:#C10D0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/269921139" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">React 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSX-%E8%AF%AD%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">JSX 语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-JSX-%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">在 JSX 中使用表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">2.2.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSX-%E5%8D%95%E6%A0%87%E8%AE%B0%E5%BF%85%E9%A1%BB%E9%97%AD%E5%90%88"><span class="toc-number">2.3.</span> <span class="toc-text">JSX 单标记必须闭合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#className"><span class="toc-number">2.4.</span> <span class="toc-text">className</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSX-%E8%87%AA%E5%8A%A8%E5%B1%95%E5%BC%80%E6%95%B0%E7%BB%84"><span class="toc-number">2.5.</span> <span class="toc-text">JSX 自动展开数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97"><span class="toc-number">2.6.</span> <span class="toc-text">三元运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.7.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.8.</span> <span class="toc-text">事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E5%BC%8F"><span class="toc-number">2.9.</span> <span class="toc-text">样式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E6%A0%B7%E5%BC%8F"><span class="toc-number">2.9.1.</span> <span class="toc-text">行内样式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%96%E9%93%BE%E6%A0%B7%E5%BC%8F"><span class="toc-number">2.9.2.</span> <span class="toc-text">外链样式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F"><span class="toc-number">2.9.3.</span> <span class="toc-text">全局样式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ref-%E5%B1%9E%E6%80%A7"><span class="toc-number">2.10.</span> <span class="toc-text">ref 属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#createRef"><span class="toc-number">2.10.1.</span> <span class="toc-text">createRef</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">2.10.2.</span> <span class="toc-text">函数参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ref-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.10.3.</span> <span class="toc-text">ref 字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.10.4.</span> <span class="toc-text">获取组件实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%84%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">什么是组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text">创建组件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B1%BB%E7%BB%84%E4%BB%B6"><span class="toc-number">3.2.1.</span> <span class="toc-text">创建类组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6"><span class="toc-number">3.2.2.</span> <span class="toc-text">创建函数组件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-props"><span class="toc-number">3.3.</span> <span class="toc-text">组件 props</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#props-%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="toc-number">3.3.1.</span> <span class="toc-text">props 传递数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-props-%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">3.3.2.</span> <span class="toc-text">设置 props 默认值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-children"><span class="toc-number">3.3.3.</span> <span class="toc-text">组件 children</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">3.3.4.</span> <span class="toc-text">单向数据流</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81-state"><span class="toc-number">3.4.</span> <span class="toc-text">类组件状态 state</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="toc-number">3.4.1.</span> <span class="toc-text">定义组件状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E7%BB%84%E4%BB%B6%E7%8A%B6%E6%80%81"><span class="toc-number">3.4.2.</span> <span class="toc-text">更改组件状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="toc-number">3.4.3.</span> <span class="toc-text">双向数据绑定</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">类组件生命周期函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Context"><span class="toc-number">3.6.</span> <span class="toc-text">Context</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95"><span class="toc-number">4.</span> <span class="toc-text">表单</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%97%E6%8E%A7%E8%A1%A8%E5%8D%95"><span class="toc-number">4.1.</span> <span class="toc-text">受控表单</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%8F%97%E6%8E%A7%E8%A1%A8%E5%8D%95"><span class="toc-number">4.2.</span> <span class="toc-text">非受控表单</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1"><span class="toc-number">5.</span> <span class="toc-text">路由</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">路由基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%B5%8C%E5%A5%97"><span class="toc-number">5.2.</span> <span class="toc-text">路由嵌套</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82"><span class="toc-number">5.3.</span> <span class="toc-text">路由传参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">5.4.</span> <span class="toc-text">路由重定向</span></a></li></ol></li></ol></div></div></div><div class="tag-cloud"><div class="tag-cloud-tags"><a href="/tags/JavaScript/" style="font-size: 27px; color: #8cbbd1">JavaScript</a> <a href="/tags/React/" style="font-size: 24px; color: #8dbad0">React</a> <a href="/tags/TypeScript/" style="font-size: 15px; color: #92b6cf">TypeScript</a> <a href="/tags/Vite/" style="font-size: 12px; color: #93b5cf">Vite</a> <a href="/tags/Vue/" style="font-size: 30px; color: #8abcd1">Vue</a> <a href="/tags/Vue3/" style="font-size: 15px; color: #92b6cf">Vue3</a> <a href="/tags/Webpack/" style="font-size: 15px; color: #92b6cf">Webpack</a> <a href="/tags/eggjs/" style="font-size: 18px; color: #90b7d0">eggjs</a> <a href="/tags/serverless/" style="font-size: 18px; color: #90b7d0">serverless</a> <a href="/tags/uniapp/" style="font-size: 21px; color: #8fb9d0">uniapp</a> <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15px; color: #92b6cf">小程序</a> <a href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" style="font-size: 15px; color: #92b6cf">工程化</a> <a href="/tags/%E6%97%A5%E8%AE%B0/" style="font-size: 12px; color: #93b5cf">日记</a> <a href="/tags/%E6%97%A5%E8%AF%AD/" style="font-size: 12px; color: #93b5cf">日语</a> <a href="/tags/%E6%A6%82%E5%BF%B5/" style="font-size: 21px; color: #8fb9d0">概念</a> <a href="/tags/%E9%83%A8%E7%BD%B2/" style="font-size: 12px; color: #93b5cf">部署</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 15px; color: #92b6cf">面试</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 15px; color: #92b6cf">项目</a></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://xxcijmz.top/blogs/1a53f83b/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="语轻星子"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="轻语馆"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">LG—React基础回顾</h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2021-12-20 18:58:12" itemprop="dateCreated datePublished" datetime="2021-12-20T18:58:12+08:00">2021-12-20</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="本文字数">4.4k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="阅读时长">20m</span></span></span><div class="post-classify"><span class="post-tag"><a class="tag-item" href="/tags/React/" style="--text-color:#61dafb"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">React</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#5698c3;"><h3 id="React-介绍"><a href="#React-介绍" class="headerlink" title="React 介绍"></a>React 介绍</h3><p><img src="/blogs/1a53f83b/1.jpg" loading="lazy"></p>
<p>React 是一个用于构建用户界面的 JavaScript 库，它只负责应用的视图层，帮助开发人员构建<strong>快速且交互式</strong>的 web 应用程序。</p>
<p>React 使用组件的方式构建用户界面。（all in js：一切都使用javascript，构建用户界面的结构、样式、逻辑）</p>
<h3 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h3><p>在 React 中使用 JSX 语法描述用户界面，它是<strong>一种 JavaScript 语法扩展</strong>。</p>
<p>在 React 代码执行之前，Babel 会将 JSX 语法转换为标准的 JavaScript API。</p>
<p>JSX 语法就是一种语法糖，让开发人员使用更加舒服的代码构建用户界面。</p>
<h4 id="在-JSX-中使用表达式"><a href="#在-JSX-中使用表达式" class="headerlink" title="在 JSX 中使用表达式"></a>在 JSX 中使用表达式</h4><pre class="language-react" data-language="react"><code class="language-react">const user &#x3D; &#123;
  firstName: &#39;Harper&#39;,
  lastName: &#39;Perez&#39;
&#125;
function formatName(user) &#123;
  return user.firstName + &#39; &#39; + user.lastName;
&#125;

&#x2F;&#x2F; 注意此处要用 &#123;&#125; 包裹表达式
const element &#x3D; &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;&#x2F;h1&gt;;</code></pre>

<p>JSX 本身其实也是一种表达式，将它赋值给变量，当作参数传入，作为返回值都可以。</p>
<pre class="language-react" data-language="react"><code class="language-react">function getGreeting(user) &#123;
  if (user) &#123;
    return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;&#x2F;h1&gt;;
  &#125;
  return &lt;h1&gt;Hello, Stranger.&lt;&#x2F;h1&gt;;
&#125;</code></pre>

<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>如果属性值为字符串类型，需要加引号，属性名称推荐采用驼峰式命名法。</p>
<pre class="language-react" data-language="react"><code class="language-react">const element &#x3D; &lt;div greeting&#x3D;&quot;hello&quot;&gt;&lt;&#x2F;div&gt;;</code></pre>

<p>如果属性值为JavaScript表达式，属性值外面加大括号。</p>
<pre class="language-react" data-language="react"><code class="language-react">const element &#x3D; &lt;img src&#x3D;&#123;user.avatarUrl&#125; &#x2F;&gt;;
&#x2F;&#x2F; 注意大括号外面不能加引号，JSX 会将引号当中的内容识别为字符串而不是表达式</code></pre>

<h4 id="JSX-单标记必须闭合"><a href="#JSX-单标记必须闭合" class="headerlink" title="JSX 单标记必须闭合"></a>JSX 单标记必须闭合</h4><p>如果 JSX 是单标记，必须闭合，否则报错。</p>
<pre class="language-react" data-language="react"><code class="language-react">const element &#x3D; &lt;img src&#x3D;&#123;user.avatarUrl&#125; &#x2F;&gt;
const element &#x3D; &lt;input type&#x3D;&quot;text&quot;&#x2F;&gt;</code></pre>

<h4 id="className"><a href="#className" class="headerlink" title="className"></a>className</h4><p>为 JSX 标记添加类名需要使用 className，而不是class。</p>
<pre class="language-react" data-language="react"><code class="language-react">const element &#x3D; &lt;img src&#x3D;&#123;user.avatarUrl&#125; className&#x3D;&quot;rounded&quot;&#x2F;&gt;;</code></pre>

<h4 id="JSX-自动展开数组"><a href="#JSX-自动展开数组" class="headerlink" title="JSX 自动展开数组"></a>JSX 自动展开数组</h4><pre class="language-react" data-language="react"><code class="language-react">const ary &#x3D; [&lt;p&gt;哈哈&lt;&#x2F;p&gt;, &lt;p&gt;呵呵&lt;&#x2F;p&gt;, &lt;p&gt;嘿嘿&lt;&#x2F;p&gt;];
const element &#x3D; (
	&lt;div&gt;&#123;ary&#125;&lt;&#x2F;div&gt;
);
&#x2F;&#x2F; 解析后，数组外的 []  会被自动去掉
&#x2F;*
	&lt;div&gt;
		&lt;p&gt;哈哈&lt;&#x2F;p&gt;
		&lt;p&gt;呵呵&lt;&#x2F;p&gt;
		&lt;p&gt;嘿嘿&lt;&#x2F;p&gt;
	&lt;&#x2F;div&gt;
*&#x2F;</code></pre>

<h4 id="三元运算"><a href="#三元运算" class="headerlink" title="三元运算"></a>三元运算</h4><pre class="language-react" data-language="react"><code class="language-react">&#123; boolean ? &lt;div&gt;Hello React&lt;&#x2F;div&gt; : null &#125;		&#x2F;&#x2F; 在 jsx 中，若返回值为 null，则在页面中什么都不会显示
&#x2F;&#x2F; 等价于
&#123; boolean &amp;&amp; &lt;div&gt;Hello React&lt;&#x2F;div&gt; &#125;		&#x2F;&#x2F; 如果 boolean 为真，显示后面的 div。</code></pre>

<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><pre class="language-react" data-language="react"><code class="language-react">const persons &#x3D; [&#123;
  id: 1,
  name: &#39;张三&#39;,
  age: 20
&#125;, &#123;
  id: 2,
  name: &#39;李四&#39;,
  age: 15
&#125;, &#123;
  id: 3,
  name: &#39;王五&#39;,
  age: 22
&#125;]</code></pre>

<pre class="language-react" data-language="react"><code class="language-react">&#x2F;&#x2F; map方法返回数组，而 jsx 中数组会被自动展开
&#x2F;&#x2F; 此处 li 必须添加 key 属性
&lt;ul&gt;
  &#123; persons.map(person &#x3D;&gt; &lt;li key&#x3D;&#123;person.id&#125;&gt; &#123;person.name&#125; &#123;person.age&#125; &lt;&#x2F;li&gt;) &#125;
&lt;&#x2F;ul&gt;</code></pre>

<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><pre class="language-react" data-language="react"><code class="language-react">&#123;&#x2F;* 第一个参数即是事件对象 不需传递事件对象 *&#x2F;&#125;
&lt;button onClick&#x3D;&#123;this.eventHandler&#125;&gt;按钮&lt;&#x2F;button&gt;
&#123;&#x2F;* 使用箭头函数的形式，需要手动传递事件对象 *&#x2F;&#125;
&lt;button onClick&#x3D;&#123;e&#x3D;&gt;this.eventHandler(&#39;arg&#39;,e)&#125;&gt;按钮&lt;&#x2F;button&gt;
&#123;&#x2F;* 使用bind的方式，最后一个参数即是事件对象 不需传递 *&#x2F;&#125;
&lt;button onClick&#x3D;&#123;this.eventHandler.bind(null, &#39;arg&#39;)&#125;&gt;按钮&lt;&#x2F;button&gt;</code></pre>

<pre class="language-react" data-language="react"><code class="language-react">constructor () &#123;
  &#x2F;&#x2F; 若不改变 this 指向，默认指向 undefined。
  &#x2F;&#x2F; 除了此种方式，还可以使用上方第三种方式改变this指向
  &#x2F;&#x2F; &lt;button onClick&#x3D;&#123;this.eventHandler.bind(this, &#39;arg&#39;)&#125;&gt;按钮&lt;&#x2F;button&gt;  
  this.eventHandler &#x3D; this.eventHandler.bind(this)
&#125;
eventHandler () &#123;&#125;
&lt;button onClick&#x3D;&#123;this.eventHandler&#125;&gt;按钮&lt;&#x2F;button&gt;</code></pre>

<h4 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h4><blockquote>
<p>添加样式时需要考虑样式只应用于组件本身，而不泄漏到外部。</p>
</blockquote>
<h5 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h5><pre class="language-react" data-language="react"><code class="language-react">class App extends Component &#123;
  render() &#123;
    &#x2F;&#x2F; 此处数值类型值可不写单位，多字母型样式需要以驼峰形式书写
    const style &#x3D; &#123;width: 200, height: 200, backgroundColor: &#39;red&#39;&#125;;
    return &lt;div style&#x3D;&#123;style&#125;&gt;&lt;&#x2F;div&gt;
  &#125;
&#125;</code></pre>

<h5 id="外链样式"><a href="#外链样式" class="headerlink" title="外链样式"></a>外链样式</h5><pre class="language-react" data-language="react"><code class="language-react">&#x2F;&#x2F; Button.js
&#x2F;&#x2F; 注意组件对应的样式文件要有命名规定
import styles from &#39;.&#x2F;Button.module.css&#39;;
class Button extends Component &#123;
  render() &#123;
      &#123;&#x2F;* styles.error 表示样式文件中类名为 error 的样式 *&#x2F;&#125;
    return &lt;button className&#x3D;&#123;styles.error&#125;&gt;Error Button&lt;&#x2F;button&gt;;
  &#125;
&#125;</code></pre>

<h5 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h5><p><strong>index.js</strong></p>
<pre class="language-react" data-language="react"><code class="language-react">import &#39;.&#x2F;styles.css&#39;</code></pre>

<h4 id="ref-属性"><a href="#ref-属性" class="headerlink" title="ref 属性"></a>ref 属性</h4><blockquote>
<p>通过 ref 属性可以获取到元素/组件的实例对象</p>
</blockquote>
<h5 id="createRef"><a href="#createRef" class="headerlink" title="createRef"></a>createRef</h5><pre class="language-react" data-language="react"><code class="language-react">class Input extends Component &#123;
  constructor() &#123;
    super()
    &#x2F;&#x2F; 通过 React.createRef() 创建一个 ref 对象，并赋值给 this.inputRef。然后将其与元素的 ref 绑定,此后便可以使用 current 属性获取到对应dom对象
    this.inputRef &#x3D; React.createRef()
  &#125;
  render() &#123;
    return (
      &lt;div&gt;
        &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&#123;this.inputRef&#125; &#x2F;&gt;
        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; console.log(this.inputRef.current)&#125;&gt; button &lt;&#x2F;button&gt;
      &lt;&#x2F;div&gt;
    )
  &#125;
&#125;</code></pre>

<h5 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h5><pre class="language-react" data-language="react"><code class="language-react">class Input extends Component &#123;
  render() &#123;
    return (
      &lt;div&gt;
        &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&#123;input &#x3D;&gt; (this.input &#x3D; input)&#125; &#x2F;&gt;		&#123;&#x2F;* 此处的 input 为当前元素对应的dom对象 *&#x2F;&#125;
        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; console.log(this.input)&#125;&gt;button&lt;&#x2F;button&gt;
      &lt;&#x2F;div&gt;
    )
  &#125;
&#125;</code></pre>

<h5 id="ref-字符串"><a href="#ref-字符串" class="headerlink" title="ref 字符串"></a>ref 字符串</h5><blockquote>
<p>不推荐使用，在严格模式下报错。</p>
</blockquote>
<pre class="language-react" data-language="react"><code class="language-react">class Input extends Component &#123;
  render() &#123;
    return (
      &lt;div&gt;
        &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&quot;username&quot; &#x2F;&gt;
        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; console.log(this.refs.username)&#125;&gt;button&lt;&#x2F;button&gt;
      &lt;&#x2F;div&gt;
    )
  &#125;
&#125;</code></pre>

<h5 id="获取组件实例"><a href="#获取组件实例" class="headerlink" title="获取组件实例"></a>获取组件实例</h5><p>需求：点击按钮让 input 文本框获取焦点。</p>
<p>input 文本框以及让文本框获取焦点的方法定义在 Input 组件中，在 App 组件中引入 Input 组件，按钮定义在 App 组件中。</p>
<pre class="language-react" data-language="react"><code class="language-react">&#x2F;&#x2F; Input.js
class Input extends Component &#123;
  constructor() &#123;
    super()
    this.inputRef &#x3D; React.createRef()
    this.focusInput &#x3D; this.focusInput.bind(this)
  &#125;
  focusInput() &#123;
    this.inputRef.current.focus()
  &#125;
  render() &#123;
    return (
      &lt;div&gt;
        &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&#123;this.inputRef&#125; &#x2F;&gt;
      &lt;&#x2F;div&gt;
    )
  &#125;
&#125;</code></pre>

<pre class="language-react" data-language="react"><code class="language-react">&#x2F;&#x2F; App.js
class App extends Component &#123;
  constructor() &#123;
    super()
    this.InputComponentRef &#x3D; React.createRef()
  &#125;
  render() &#123;
    return (
      &lt;div className&#x3D;&quot;App&quot;&gt;
        &lt;Input ref&#x3D;&#123;this.InputComponentRef&#125; &#x2F;&gt;
        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; this.InputComponentRef.current.focusInput()&#125;&gt;button&lt;&#x2F;button&gt;
      &lt;&#x2F;div&gt;
    )
&#125;</code></pre>

<p><img src="/blogs/1a53f83b/2.gif" loading="lazy"></p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><h4 id="什么是组件"><a href="#什么是组件" class="headerlink" title="什么是组件"></a>什么是组件</h4><p>React 是基于组件的方式进行用户界面开发的. 组件可以理解为对页面中某一块区域的封装。</p>
<p><img src="/blogs/1a53f83b/2.jpg" loading="lazy"></p>
<h4 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h4><h5 id="创建类组件"><a href="#创建类组件" class="headerlink" title="创建类组件"></a>创建类组件</h5><pre class="language-react" data-language="react"><code class="language-react">import React, &#123; Component &#125; from &#39;react&#39;;		&#x2F;&#x2F; 代码中虽然没有使用React，但是 jsx 代码在执行之前会被转化为 React.createElement() 方法
class App extends Component &#123;
    render () &#123;
        return &lt;div&gt;Hello, 我是类组件&lt;&#x2F;div&gt;
    &#125;
&#125;</code></pre>

<h5 id="创建函数组件"><a href="#创建函数组件" class="headerlink" title="创建函数组件"></a>创建函数组件</h5><pre class="language-react" data-language="react"><code class="language-react">const Person &#x3D; () &#x3D;&gt; &#123;
     return &lt;div&gt;Hello, 我是函数型组件&lt;&#x2F;div&gt;;
&#125;</code></pre>

<p><strong>注意事项</strong></p>
<ol>
<li>组件名称首字母必须大写，用以区分组件和普通标签。</li>
<li>jsx语法外层必须有一个根元素。</li>
</ol>
<h4 id="组件-props"><a href="#组件-props" class="headerlink" title="组件 props"></a>组件 props</h4><h5 id="props-传递数据"><a href="#props-传递数据" class="headerlink" title="props 传递数据"></a>props 传递数据</h5><p>在调用组件时可以向组件内部传递数据，在组件中可以通过 props 对象获取外部传递进来的数据。</p>
<pre class="language-react" data-language="react"><code class="language-react">&lt;Person name&#x3D;&quot;乔治&quot; age&#x3D;&quot;20&quot;&#x2F;&gt;
&lt;Person name&#x3D;&quot;玛丽&quot; age&#x3D;&quot;10&quot;&#x2F;&gt;</code></pre>

<pre class="language-react" data-language="react"><code class="language-react">&#x2F;&#x2F; 类组件
class Person extends Component &#123;
  render() &#123;
    return (
      &lt;div&gt;
        &lt;h3&gt;姓名：&#123;this.props.name&#125;&lt;&#x2F;h3&gt;
        &lt;h4&gt;年龄：&#123;this.props.age&#125;&lt;&#x2F;h4&gt;
      &lt;&#x2F;div&gt;
    );
  &#125;
&#125;</code></pre>

<pre class="language-react" data-language="react"><code class="language-react">&#x2F;&#x2F; 函数组件
const Person &#x3D; props &#x3D;&gt; &#123;
  return (
    &lt;div&gt;
      &lt;h3&gt;姓名：&#123;props.name&#125;&lt;&#x2F;h3&gt;
      &lt;h4&gt;年龄：&#123;props.age&#125;&lt;&#x2F;h4&gt;
    &lt;&#x2F;div&gt;
  );
&#125;</code></pre>

<p><strong>注意：</strong></p>
<ol>
<li>props 对象中存储的数据是只读的，不能在组件内部被修改。</li>
<li>当 props 数据源中的数据被修改后，组件中的接收到的 props 数据会被同步更新。( 数据驱动DOM )</li>
</ol>
<h5 id="设置-props-默认值"><a href="#设置-props-默认值" class="headerlink" title="设置 props 默认值"></a>设置 props 默认值</h5><pre class="language-react" data-language="react"><code class="language-react">&#x2F;&#x2F; 类组件
 class App extends Component &#123;
    static defaultProps &#x3D; &#123;&#125;
&#125;</code></pre>

<pre class="language-react" data-language="react"><code class="language-react">&#x2F;&#x2F; 函数组件
function ThemedButton(props) &#123;
&#125;
ThemedButton.defaultProps &#x3D; &#123;
  theme: &quot;secondary&quot;,
  label: &quot;Button Text&quot;
&#125;;</code></pre>

<h5 id="组件-children"><a href="#组件-children" class="headerlink" title="组件 children"></a>组件 children</h5><p>通过 props.children 属性可以获取到在调用组件时填充到组件标签内部的内容。</p>
<pre class="language-react" data-language="react"><code class="language-react">&lt;Person&gt;组件内部的内容&lt;&#x2F;Person&gt;</code></pre>

<pre class="language-react" data-language="react"><code class="language-react">const Person &#x3D; (props) &#x3D;&gt; &#123;
    return (
    	&lt;div&gt;&#123;props.children&#125;&lt;&#x2F;div&gt;		&#x2F;&#x2F; &lt;div&gt;组件内部的内容&lt;&#x2F;div&gt;
    );
&#125;</code></pre>

<h5 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h5><ol>
<li><p>在React中, 关于数据流动有一条原则, 就是单向数据流动, 自顶向下, 从父组件到子组件。</p>
</li>
<li><p>单向数据流特性要求我们<strong>共享数据要放置在上层组件</strong>中。</p>
</li>
<li><p>子组件通过调用父组件传递过来的方法更改数据。</p>
</li>
<li><p>当数据发生更改时, React会重新渲染组件树（数据更改，同步更新使用到数据的组件）。</p>
</li>
<li><p>单向数据流使组件之间的数据流动变得可预测. 使得定位程序错误变得简单。</p>
<p><img src="/blogs/1a53f83b/3.jpg" loading="lazy"></p>
</li>
</ol>
<h4 id="类组件状态-state"><a href="#类组件状态-state" class="headerlink" title="类组件状态 state"></a>类组件状态 state</h4><blockquote>
<p>state 用于存储组件内部的数据，内部数据更新，dom也会跟着更新。</p>
</blockquote>
<h5 id="定义组件状态"><a href="#定义组件状态" class="headerlink" title="定义组件状态"></a>定义组件状态</h5><p>类组件除了能够从外部 (props) 接收状态数据以外还可以拥有自己的状态 (state)，此状态在组件内部可以被更新，状态更新 DOM 更新。</p>
<p>组件内部的状态数据被存储在组件类中的 state 属性中，state 属性值为<strong>对象类型</strong>，属性名称固定不可更改。</p>
<pre class="language-react" data-language="react"><code class="language-react">class App extends Component &#123;
  constructor () &#123;
    super()
    this.state &#x3D; &#123;
      person: &#123; name: &#39;张三&#39;, age: 20 &#125;,
    &#125;
  &#125;
  render () &#123;
    return (
      &lt;div&gt;
        &#123;this.state.person.name&#125;
        &#123;this.state.person.age&#125;
      &lt;&#x2F;div&gt;
    );
  &#125;
&#125;</code></pre>

<h5 id="更改组件状态"><a href="#更改组件状态" class="headerlink" title="更改组件状态"></a>更改组件状态</h5><p>state 状态对象中的数据不可直接更改，如果<strong>直接更改 DOM 不会被更新</strong>，要更改 state 状态数据需要使用 <strong>setState</strong>方法。</p>
<pre class="language-react" data-language="react"><code class="language-react">class App extends Component &#123;
  constructor () &#123;
    this.state &#x3D; &#123;
      person: &#123; name: &#39;张三&#39;, age: 20 &#125;,
    &#125;
    this.changePerson &#x3D; this.changePerson.bind(this)
  &#125;
	changePerson () &#123;
    this.setState(&#123;
      person: &#123;
        name: &#39;李四&#39;,
        age: 15
      &#125;
    &#125;)
  &#125;
  render() &#123;
    return (
      &lt;div&gt;
        &#123;this.state.person.name&#125;
        &#123;this.state.person.age&#125;
        &lt;button onClick&#x3D;&#123;this.changePerson&#125;&gt;按钮&lt;&#x2F;button&gt;
      &lt;&#x2F;div&gt;
    );
  &#125;
&#125;</code></pre>

<h5 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h5><p>双向数据绑定是指，组件类中更新了状态，DOM 状态同步更新，DOM 更改了状态，组件类中同步更新。组件 &lt;=&gt; 视图。</p>
<p>要实现双向数据绑定需要用到表单元素和 state 状态对象。</p>
<pre class="language-react" data-language="react"><code class="language-react">class App extends Component &#123;
  constructor () &#123;
    this.state &#x3D; &#123;
      name: &quot;张三&quot;
    &#125;
    this.nameChanged &#x3D; this.nameChanged.bind(this)
  &#125;
  nameChanged (event) &#123;
    this.setState(&#123;name: event.target.value&#125;);
  &#125;
  render() &#123;
    return (
      &lt;div&gt;
        &lt;div&gt;&#123;this.state.name&#125;&lt;&#x2F;div&gt;
        &#x2F;&#x2F; 给Person 组件传递一个name属性以及changed方法
        &lt;Person name&#x3D;&#123;this.state.name&#125; changed&#x3D;&#123;this.nameChanged&#125;&#x2F;&gt;
      &lt;&#x2F;div&gt;
    )
  &#125;
&#125;</code></pre>

<pre class="language-react" data-language="react"><code class="language-react">const Person &#x3D; props &#x3D;&gt; &#123;
	return &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;props.name&#125; onChange&#x3D;&#123;props.changed&#125;&#x2F;&gt;;
&#125;</code></pre>

<h4 id="类组件生命周期函数"><a href="#类组件生命周期函数" class="headerlink" title="类组件生命周期函数"></a>类组件生命周期函数</h4><blockquote>
<p>组件的生命周期函数分为三个阶段：挂载阶段、数据更新阶段、卸载阶段</p>
</blockquote>
<p><strong>组件挂载阶段：</strong></p>
<ol>
<li><p>constructor 中可以更改函数的 this 指向。</p>
</li>
<li><p>getDerivedStateFromProps 中有两个参数（通过Props接收到的父组件传递来的state，组件本身的state）。通过这两个参数决定是否要更新当前组件的state，如果不需要更新，返回null。如果需要更新，返回一个全新的状态对象。不可什么都不返回。</p>
</li>
<li><p>render 方法中挂载 dom 对象。</p>
</li>
<li><p>componentDidMount 表示当前组件已经挂载完成。此处可以向服务器端发送请求等。</p>
</li>
</ol>
<p><strong>组件更新阶段：</strong></p>
<ol>
<li>getDerivedStateProps 检查状态有没有必要发生更新。替换了之前的 componentWillReceiveProps 函数。</li>
<li>shouldComponentUpdate 需要返回 true 或 false。返回 true 继续运行下面的生命周期函数，返回 false 就停止更新组件，不再执行剩余生命周期函数。</li>
<li>render 方法中挂载 dom 对象。</li>
<li>getSnapshotBeforeUpdate 中需要做某种逻辑或者计算，返回的值将作为 componentDidUpdate 的第三个参数。两个生命周期函数需要配合使用。</li>
</ol>
<p><strong>组件卸载阶段：</strong></p>
<ol>
<li>componentWillUnmount：做一些 清理操作(清理绑定的dom事件、清理通过 ref 属性绑定的 dom 对象)。</li>
</ol>
<p><img src="/blogs/1a53f83b/4.jpg" loading="lazy"></p>
<p>在组件完成更新之前需要做某种逻辑或者计算，就需要用到快照</p>
<pre class="language-react" data-language="react"><code class="language-react">componentDidUpdate(prevProps, prevState, snapshot) &#123;&#125;</code></pre>

<p>getSnapshotBeforeUpdate 方法会在组件完成更新之前执行，用于执行某种逻辑或计算，返回值可以在 componentDidUpdate 方法中的第三个参数中获取，就是说在组件更新之后可以拿到这个值再去做其他事情。</p>
<pre class="language-react" data-language="react"><code class="language-react">getSnapshotBeforeUpdate(prevProps, prevState) &#123;
  return &#39;snapshot&#39;
&#125;</code></pre>

<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>通过 Context 可以跨层级传递数据</p>
<p><img src="/blogs/1a53f83b/5.jpg" loading="lazy"></p>
<pre class="language-react" data-language="react"><code class="language-react">&#x2F;&#x2F; userContext.js
import React from &quot;react&quot;

const userContext &#x3D; React.createContext(&quot;default value&quot;)	&#x2F;&#x2F; createContext() 中可以传递默认数据
const UserProvider &#x3D; userContext.Provider	&#x2F;&#x2F; Provider 用于传递数据
const UserConsumer &#x3D; userContext.Consumer	&#x2F;&#x2F; Consumer 用于取数据

export &#123; UserProvider, UserConsumer &#125;</code></pre>

<pre class="language-react" data-language="react"><code class="language-react">&#x2F;&#x2F; App.js
import &#123; UserProvider &#125; from &quot;.&#x2F;userContext&quot;
class App extends Component &#123;
  render() &#123;
    return (
      &lt;UserProvider value&#x3D;&quot;Hello React Context&quot;&gt;
        &lt;A &#x2F;&gt;
      &lt;&#x2F;UserProvider&gt;
    )
  &#125;
&#125;</code></pre>

<pre class="language-react" data-language="react"><code class="language-react">&#x2F;&#x2F; C.js
import &#123; UserConsumer &#125; from &quot;.&#x2F;userContext&quot;

export class C extends Component &#123;
  render() &#123;
    return (
      &lt;div&gt;
        &lt;UserConsumer&gt;
          &#123;username &#x3D;&gt; &#123;
            return &lt;div&gt;&#123;username&#125;&lt;&#x2F;div&gt;
          &#125;&#125;
        &lt;&#x2F;UserConsumer&gt;
      &lt;&#x2F;div&gt;
    )
  &#125;
&#125;</code></pre>

<p>context 的另一种用法</p>
<pre class="language-react" data-language="react"><code class="language-react">&#x2F;&#x2F; userContext.js
export default userContext</code></pre>

<pre class="language-react" data-language="react"><code class="language-react">&#x2F;&#x2F; C.js
import userContext from &quot;.&#x2F;userContext&quot;

export class C extends Component &#123;
  static contextType &#x3D; userContext
  render() &#123;
    return (
      &lt;div&gt;
        &#123;this.context&#125;
      &lt;&#x2F;div&gt;
    )
  &#125;
&#125;</code></pre>

<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><h4 id="受控表单"><a href="#受控表单" class="headerlink" title="受控表单"></a>受控表单</h4><p>表单控件中的值由组件的 state 对象来管理，state对象中存储的值和表单控件中的值时同步状态的</p>
<pre class="language-react" data-language="react"><code class="language-react">class App extends Component &#123;
  constructor () &#123;
    this.state &#x3D; &#123; username: &quot;&quot; &#125;
    this.nameChanged &#x3D; this.nameChanged.bind(this)
  &#125;
  
  nameChanged (e) &#123;
    this.setState(&#123;username: e.target.value&#125;)
  &#125;
  render() &#123;
    return (
      &lt;form&gt;
        &lt;p&gt;&#123;this.state.username&#125;&lt;&#x2F;p&gt;
        &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;this.state.username&#125; onChange&#x3D;&#123;this.nameChanged&#125;&#x2F;&gt;
      &lt;&#x2F;form&gt;
    )
  &#125;
&#125;</code></pre>

<h4 id="非受控表单"><a href="#非受控表单" class="headerlink" title="非受控表单"></a>非受控表单</h4><p>表单元素的值由 DOM 元素本身管理。</p>
<pre class="language-react" data-language="react"><code class="language-react">class App extends Component &#123;
  constructor () &#123;
    this.onSubmit &#x3D; this.onSubmit.bind(this)
  &#125;
  onSubmit(e) &#123;
    &#x2F;&#x2F; 通过如下方式获取非受控表单的值
    console.log(this.username.value)
    e.preventDefault();
  &#125;
  render(
    &lt;form onSubmit&#x3D;&#123;this.onSubmit&#125;&gt;
      &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&#123;username &#x3D;&gt; this.username &#x3D; username&#125;&#x2F;&gt;
    &lt;&#x2F;form&gt;
  )
&#125;</code></pre>

<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>url地址与组件之间的对应关系，访问不同的url地址显示不同的组件。</p>
<p>下载：<code>npm install react-router-dom</code></p>
<h4 id="路由基本使用"><a href="#路由基本使用" class="headerlink" title="路由基本使用"></a>路由基本使用</h4><pre class="language-react" data-language="react"><code class="language-react">&#x2F;&#x2F; App.js
import React from &#39;react&#39;;
import &#123; BrowserRouter as Router, Route, Link &#125; from &#39;react-router-dom&#39;;
function Index() &#123;
	return &lt;div&gt;首页&lt;&#x2F;div&gt;;
&#125;
function News() &#123;
	return &lt;div&gt;新闻&lt;&#x2F;div&gt;;
&#125;
function App() &#123;
  return (
    &lt;Router&gt;
      &lt;div&gt;
        &lt;Link to&#x3D;&quot;&#x2F;index&quot;&gt;首页&lt;&#x2F;Link&gt;
        &lt;Link to&#x3D;&quot;&#x2F;news&quot;&gt;新闻&lt;&#x2F;Link&gt;
      &lt;&#x2F;div&gt;
      &lt;div&gt;
        &lt;Route path&#x3D;&quot;&#x2F;index&quot; component&#x3D;&#123;Index&#125;&#x2F;&gt;
        &lt;Route path&#x3D;&quot;&#x2F;news&quot; component&#x3D;&#123;News&#125;&#x2F;&gt;
      &lt;&#x2F;div&gt;
    &lt;&#x2F;Router&gt;
  );
&#125;</code></pre>

<h4 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h4><blockquote>
<p>News组件中还包含两个不同的组件</p>
</blockquote>
<pre class="language-react" data-language="react"><code class="language-react">function News(props) &#123;
  return (
    &lt;div&gt;
      &lt;div&gt;
        &lt;!-- 注意此处作为二级链接，前方需要包含一级链接的路径 --&gt;
        &lt;Link to&#x3D;&#123;&#96;$&#123;props.match.url&#125;&#x2F;company&#96;&#125;&gt;公司新闻&lt;&#x2F;Link&gt;
        &lt;Link to&#x3D;&#123;&#96;$&#123;props.match.url&#125;&#x2F;industry&#96;&#125;&gt;行业新闻&lt;&#x2F;Link&gt;
      &lt;&#x2F;div&gt;
      &lt;div&gt;
        &lt;Route path&#x3D;&#123;&#96;$&#123;props.match.path&#125;&#x2F;company&#96;&#125; component&#x3D;&#123;CompanyNews&#125; &#x2F;&gt;
        &lt;Route path&#x3D;&#123;&#96;$&#123;props.match.path&#125;&#x2F;industry&#96;&#125; component&#x3D;&#123;IndustryNews&#125;&#x2F;&gt;  
      &lt;&#x2F;div&gt;	
    &lt;&#x2F;div&gt;
  );
&#125;

function CompanyNews() &#123;
	return &lt;div&gt;公司新闻&lt;&#x2F;div&gt;
&#125;
function IndustryNews() &#123;
	return &lt;div&gt;行业新闻&lt;&#x2F;div&gt;
&#125;</code></pre>

<h4 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h4><pre class="language-react" data-language="react"><code class="language-react">import url from &#39;url&#39;;		&#x2F;&#x2F; url 模块需要提前下载
class News extends Component &#123;
  constructor(props) &#123;
    super(props);
    this.state &#x3D; &#123;
      list: [&#123;
        id: 1,
        title: &#39;新闻1&#39;
      &#125;, &#123;
        id: 2,
        title: &#39;新闻2&#39;
      &#125;]
    &#125;
  &#125;
    
  render() &#123;
    return (
      &lt;div&gt;
        &lt;div&gt;新闻列表组件&lt;&#x2F;div&gt;
        &lt;ul&gt;
          this.state.list.map((item, index) &#x3D;&gt; &#123;
            return (
              &lt;li key&#x3D;&#123;index&#125;&gt;
                &lt;Link to&#x3D;&#123;&#96;&#x2F;detail?id&#x3D;$&#123;item.id&#125;&#96;&#125;&gt;&#123;item.title&#125;&lt;&#x2F;Link&gt;
              &lt;&#x2F;li&gt;
            );
          &#125;)
        &lt;&#x2F;ul&gt;
      &lt;&#x2F;div&gt;
    );
  &#125;
&#125;
class Detail extends Component &#123;
  constructor(props) &#123;
    super(props);
  &#125;
	const &#123; query &#125; &#x3D; url.parse(this.props.location.search, true);  &#x2F;&#x2F; 第二个参数为 true 表示要将参数转为对象类型
	console.log(query); &#x2F;&#x2F; &#123;id: 1&#125;
  render() &#123;
    return &lt;div&gt;新闻详情&lt;&#x2F;div&gt;
  &#125;
&#125;</code></pre>

<h4 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h4><pre class="language-react" data-language="react"><code class="language-react">import &#123; Redirect &#125; from &#39;react-router-dom&#39;;

class Login extends Component &#123;
  render() &#123;
    if (this.state.isLogin) &#123;
      return &lt;Redirect to&#x3D;&quot;&#x2F;&quot;&#x2F;&gt;
    &#125;
  &#125;
&#125;</code></pre>



</div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>语轻星子</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://xxcijmz.top/blogs/1a53f83b/" title="LG—React基础回顾">https://xxcijmz.top/blogs/1a53f83b/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/blogs/cb0fa0de/" rel="prev" title="LG-React中VirtualDOM及Diff算法"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">LG-React中VirtualDOM及Diff算法</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/blogs/828ccc9a/" rel="next" title="React学习笔记"><span class="post-nav-text">React学习笔记</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>要不要和我说些什么？</span><br></div><div id="valine-container"></div><script>Yun.utils.getScript("https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js", () => {
  const valineConfig = {"enable":true,"appId":"MnqOxUn1tp2XfaBiRJqcPNC3-MdYXbMMI","appKey":"BUJAYYUt5IhdIDVVvHH8aHMx","placeholder":"来与我一起讨论吧","avatar":null,"pageSize":10,"visitor":false,"highlight":true,"recordIP":false,"enableQQ":true,"meta":["nick"],"el":"#valine-container","lang":"zh-cn"}
  valineConfig.path = "/blogs/1a53f83b/"
  new Valine(valineConfig)
}, window.Valine);</script></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://beian.miit.gov.cn/" target="_blank">闽ICP备2021017107号-1</a></div><div class="copyright"><span>&copy; 2021 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 语轻星子</span></div><div class="live_time"><span>本博客已运行：</span><span id="display_live_time"></span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2021-09-23T00:03:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#5698c3" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script defer src="https://cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script><script defer src="https://cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script><script defer src="/js/search/algolia-search.js"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div class="algolia-pagination" id="algolia-pagination"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/live2d-widget@^3.1.3/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.9},"dialog":{"enable":true},"log":false});</script></body></html>